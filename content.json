{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/07/hello-world/"},{"title":"My_First_Post","text":"第一次部署总算是把页面部署好了(django写的因为自己不会前端+审美强迫症暂时留坑)，虽然还有很多不完善的地方，但是暂时来说基本上能用就行了，后期可能会添加评论，分享以及广告之类的功能&amp;&amp;备案&amp;&amp;申请新的域名之类的功能。 碎碎念 作为一名cs学生，以后博客应该还是偏向技术性的，目前已经想好的是将leetcode每日一题题解和代码发布在博客。一些读书笔记，比如CCIA，可能会学习的golang，unix programming interface之类的（书买太多了2333） 联系PO一下联系方式吧，万一哪天我就有读者了呢hhhh 邮箱：woshizhansen@gmail.com qq: 1369905261 1printf(&quot;Keep coding and move forward!\\n&quot;);","link":"/2020/09/06/My-First-Post/"},{"title":"9月7号leetcode每日一题","text":"原题链接:前k个高频元素 思考过程首先最直白的方法肯定是统计数字出现频率，然后排序选出频率最高的前K个数字。但是既然会用到排序，那么复杂度就会来到 O(nlogn),不太符合题目的要求。这时候很自然的就想到了快速的partition来进行划分，划分出来频率高的一边有k个即可。另外一种想法就是(纯靠自己乱想的)，因为题目保证答案唯一，所以频率最高的前K个数字是确定的，使用map计数，然后每轮对元素数目每次减去1，这样某一轮过后，必定会在map中只剩K个元素，最后push到结果即可。 自行思考的方法1234567891011121314151617181920vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int,int&gt; mp; for(auto&amp; item:nums){ ++mp[item]; } int cnt = mp.size(); while(cnt&gt;k){ for(auto&amp; item:mp){ item.second--; if(item.second==0){ --cnt; } } } vector&lt;int&gt; ans; for(auto&amp; item:mp){ if(item.second&gt;0)ans.push_back(item.first); } return ans; quick sort12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) { int picked = rand() % (end - start + 1) + start; swap(v[picked], v[start]); int pivot = v[start].second; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (v[i].second &gt;= pivot) { swap(v[index + 1], v[i]); index++; } } swap(v[start], v[index]); if (k &lt;= index - start) { qsort(v, start, index - 1, ret, k); } else { for (int i = start; i &lt;= index; i++) { ret.push_back(v[i].first); } if (k &gt; index - start + 1) { qsort(v, index + 1, end, ret, k - (index - start + 1)); } } } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v: nums) { occurrences[v]++; } vector&lt;pair&lt;int, int&gt;&gt; values; for (auto&amp; kv: occurrences) { values.push_back(kv); } vector&lt;int&gt; ret; qsort(values, 0, values.size() - 1, ret, k); return ret; }}; minimum heap1234567891011121314151617181920212223242526272829303132333435class Solution {public: /* 提醒一下，这里定义成员函数的话要尾置const,定义priority的cmp函数都要注意这一点。 */ static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) { return m.second &gt; n.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp); for (auto&amp; [num, count] : occurrences) { if (q.size() == k) { if (q.top().second &lt; count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector&lt;int&gt; ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; }}; 总结总的来说，快排的思路最好想，平均时间复杂度也只有O(n)，虽然最坏是O（n^2），小根堆则是利用了数据结构的特点，但是其时间复杂度并不太好O（nlogk），我自己想的方法就参考一下吧（其实有点像快乐模拟23333）。","link":"/2020/09/07/leetcode-daily-0907/"}],"tags":[{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"min heap","slug":"min-heap","link":"/tags/min-heap/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"leetcode-daily","slug":"leetcode-daily","link":"/categories/leetcode-daily/"}]}