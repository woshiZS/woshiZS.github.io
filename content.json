{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/06/hello-world/"},{"title":"My_First_Post","text":"第一次部署总算是把页面部署好了(django写的因为自己不会前端+审美强迫症暂时留坑)，虽然还有很多不完善的地方，但是暂时来说基本上能用就行了，后期可能会添加评论，分享以及广告之类的功能&amp;&amp;备案&amp;&amp;申请新的域名之类的功能。 碎碎念 作为一名cs学生，以后博客应该还是偏向技术性的，目前已经想好的是将leetcode每日一题题解和代码发布在博客。一些读书笔记，比如CCIA，可能会学习的golang，unix programming interface之类的（书买太多了2333） 联系PO一下联系方式吧，万一哪天我就有读者了呢hhhh 邮箱：woshizhansen@gmail.com qq: 1369905261 1printf(&quot;Keep coding and move forward!\\n&quot;);","link":"/2020/09/06/My-First-Post/"},{"title":"面试复盘(联合索引)","text":"preface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天一面感觉还算比较典型，面试官也没有为难的意思，问的题目大多都比较典型，主要类型是数据库和网络，然后问到了一个联合索引的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致意思是在a,b,c三个列上建立联合索引，然后问 12SELECT * FROM users WHERE a&gt;A AND b&gt;B; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个查询语句是否会经过索引。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正确答案是会经过索引，这里所涉及到的一个知识点就是最左前缀匹配。 索引及其性能优化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本好处： 首先就是会使查找变快，这种加速在进行多表连接的时候尤为明显。 索引会显著减少磁盘IO次数，并且如果搜查结果只包含索引列，那么查找甚至都不会检索数据行而是直接读取索引。请注意这一点，如果你的所有数据列都建了索引，那没你的任何一次查找都会走索引，就不会读磁盘（即人们常说的回表）。\\ 索引分类主要分为四种： non unique unique Primary Key Fulltext Index(全文索引) 增加或者删除索引的语法这里就不说了，很简单的，可以自己去查，接下来重点说一下show index这个语句中每个字段的具体意思。 1SHOW INDEX FROM CountryLanguage; field meaning Table represent table name Non-unique if it is a unique index or not Key name alias to this index seq_in_index 联合索引的位置（如果是单个索引的话就是1） Colun_name indexed column name collation 每个collation都归属于一个字符集，每个字符集合都至少有一个collation,collation的作用就是帮助数据库进行排序 cardinality unique value in this column sub_part 如果该列只有部分建立索引，则显示被索引部分的下表，全部都有索引的话则显示null Packed Indiacate how the key is packed.Null if it is not NULL 如果该列可能含有null值的话就显示yes，如果不含有的话就为空 Index_type index method used Index_comment 创建index的时候你如果加了注释就有这个字段 comment 额外的注释信息，例如disable,老实说这个没看懂2333 visible if the optimizer can see the index Using Index使用索引的时候有一些要注意的点： indexed column最好是非NULL的，检索时对NULL进行比较需要额外的判断 不要过度使用索引，首先添加索引是需要消耗空间的，并且如果索引太多的话，每次对表进行更新都需要花费大量的时间和资源去维护已有的索引。 老生常谈的，索引列的值要是大部分都是一致的，索引的效率就会接近于table scan 选择合适的索引类型，比如说某一列是enum类型的话，就最好选择non_unique索引类型 减少建立索引字段的长度，就比如说mysql会在内存里面缓存一些rows来避免过多的磁盘I/O，如果选择整个列的字段作为索引的话，所占空间相对来说就会变较大，所以我们可以选择部分字段来建立索引。 不要建立互有重叠的索引，比如说两个联合索引初始列是相同的，因为最左前缀匹配原则。 Indexing column Prefixes使用整个字段进行索引建立会有如下三个缺点： 需要从磁盘中读取更多的信息 较长的值需要花费较长的时间去比较 index cache会因为字段太长而只能存储比较少的字段，导致优化效率变低。 所以我们可以使用如下语法来建立prefix索引 1234CREATE TABLE t( name char(255), INDEX (name(25))); 但是这样又会引发一个问题，字段如果太短，会造成index字段差异不够大，就是说name前多少个字符相差都不大，这样的话就会降低索引的性能，所以我们应该在长度和uniqueness之间做一个折中。我们可以使用如下语句进行比较 1234567891011121314151617SELECT COUNT(*) AS 'Total Rows', COUNT(DISTINCT name) AS 'Distinct Values', COUNT(*) - COUNT(DISTINCT name) AS 'Duplicate Values'FROM t;SELECT COUNT(DISTINCT LEFT(name,n)) AS 'Distinct Prefix Values', COUNT(*) - COUNT(DISTINCT LEFT(name,n)) AS 'Duplicate Prefix Values'FROM t; 通过不断调整n的大小来对两组数据进行对比，来进行一个折中。还有一点需要注意的是，如果你对primary key或者unique key进行prefix indexing 的时候，要确保前缀也是不相同的，否则就要改变index的类型。 Leftmost Index Prefixes最左前缀匹配可以减少重复的索引建立，比如说面试题中的a,b,c作为composite index，查询时仅使用a,b是使用到index的。具体是否经过索引可以使用explain进行检测。 Fulltext Indexes注意事项： 全文索引目前只有MyISAM 数据类型只能是char,varchar或者text类型，不能是binary 全文索引是case insensitive的。创建全文索引的语法 12345678910CREATE TABLE t (name CHAR(40), FULLTEXT (name));ALTER TABLE t ADD FULLTEXT name_idx (name);ALTER TABLE t DROP INDEX name_idx;CREATE FULLTEXT INDEX name_idx ON t (name);DROP INDEX name_idx ON t; 全文索引不支持前缀索引，如果使用前缀，mysql会忽略这个请求 因为全文索引不支持前缀索引，所以全文索引也不支持最左前缀匹配，要使用不同的组合的话，要分别建立索引 使用示例： 1SELECT * FROM t WHERE MATCH(name) AGAINST('Wendell'); 这条语句用来检索，name列中含有Wendell的字段。记住，要是对不同列或者组合进行全文索引查询，需要分别建立索引。 本文参考了 Index Optimization and Index Usage以及mysql使用手册。","link":"/2020/09/14/interview-review/"},{"title":"9月8号leetcode每日一题","text":"原题链接 组合 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题刚拿到一看就比较典型，组合选k个数字，应该可以用dfs解决。但是这道题要求的是组合，如果按照循环遍历选一个再用bool数组记录选取情况的话，会产生很多不必要的递归路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此要确定每个组合只有一个排列会push到最终结果，方法就是规定一个顺序即可，这里就规定递增顺序即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是做出来之后效率比较低下，应该是没有进行剪枝，仔细一想，每次要求遍历开始的部分直接从已有数字+1开始（数组为空时取1即可），修改之后最大时间缩短为十分之一。然而超过人数占比并不理想，所以在想了想，要是当前剩余可遍历元素少于所需元素个数，好像也可以直接返回，最后运行结果16ms,超过94%。 dfs递归代码12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void dfs(int left,int n,vector&lt;int&gt;&amp; target){ if(left==0){ ans.push_back(target); return; } int i = target.empty()? 1 :target.back()+1; int bound = n - left + 1; for(;i&lt;=bound;++i){ target.push_back(i); dfs(left-1,n,target); target.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { //注意不是排列是组合，所以要想个办法使得每个组合的排列只出现一次， //好像规定组合内数字递增即可，递增算是同一组合的唯一排序 vector&lt;int&gt; temp; dfs(k,n,temp); return ans; }}; 非递归二进制组合代码思路这里是官方题解中给出的思路，意思就是选取k个数字，转换为一个n位2进制数应该是k个1，n-k个0，我们要找到一种从最低k位全1到最高k位全1的变换方法，这种方法很好理解，就是先最高位加1，然后整体从高到低都加1。一轮过后最高位加1，再开始。**注意代码实现使用了一点小trick，即在尾部多添加一个n+1的数字，其实在1到n之外的数字都行，仔细品味2333**。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { // 初始化 // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k] // 末尾加一位 n + 1 作为哨兵 for (int i = 1; i &lt;= k; ++i) { temp.push_back(i); } temp.push_back(n + 1); int j = 0; while (j &lt; k) { ans.emplace_back(temp.begin(), temp.begin() + k); j = 0; // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t] while (j &lt; k &amp;&amp; temp[j] + 1 == temp[j + 1]) { temp[j] = j + 1; ++j; } // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置 ++temp[j]; } return ans; }}; 总结题目算是在普通dfs上的一个变式，时间效率上的pogai也再次提醒我们剪枝的重要性，另外利用二进制数进行模拟这种方法还是比较难想到的，算是拓宽视野了。 碎碎念今天终于收到字节面试通知了，有点开心又有点紧张，总之努力准备，加油！","link":"/2020/09/08/leetcode-0908/"},{"title":"9月9日leetcode每日一题","text":"原题链接: 组合总和 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说句题外话，这道题和昨天的那道组合数基本一样，只不过要自己额外做点处理，甚至在剪枝的要求上还不如昨天那道题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拿到这道题的第一想法就是我先用大的数去减这个target，减不动了再用小一点的数字。这一点很好理解，相当于将所有可行解按照解的长度由小到大排列。但是这里没有保证数组有序，所以预先排序即可。但是第一次实现的时候，发现有重复组合，消除重复组合的方法昨天的博客里面已经提到，限定一种顺序即可，这里我们按照从大到小的顺序，因为可以重复选取元素，所记得选元素的时候可以是小于等于。 代码123456789101112131415161718192021222324class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; curr){ if(left==0){ ans.push_back(curr); return; } for(int i = candi.size()-1;i&gt;=0;--i){ if(left&gt;=candi[i]&amp;&amp;(curr.empty()||curr.back()&gt;=candi[i])){ curr.push_back(candi[i]); traverse(left-candi[i],candi,curr); curr.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp); return ans; }}; 总结这里要注意一点要先判定curr是否为空再判断curr.back()与candi[i]的大小关系，不然会出现访问不存在元素的未定义行为，所以书本里面写的很有道理，先检查边界有效性，再检查内容。另外提一句，这里时间效率已经超过90%，进一步剪枝的话就把curr.empty()和curr.back()&gt;=candi[i]这个判定拉出来，直接让i从符合条件的位置开始遍历，或者再在traverse中添加一个index参数，记录上次选取的index，这次选取就从index（想想为什么不是index-1?）开始递减遍历。","link":"/2020/09/09/leetcode-0909/"},{"title":"9月10号leetcode每日一题","text":"原题链接: 组合总和|| 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天还是组合类型题目，无语…唯一的区别就是每个数字之可以选取一次，并且可选数字中会出现重复的数字，所以这道题最大的难点在于去重。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要去重就要分析可能出现重复的情况，举个例子来自说，target是11，candidates是[1,10,10]，这样就会出现重复的解，为了避免这样的情况，需要做的就是在每一轮递归的过程中不要选取重复的值（这里的意思并不是说排查了一个数字选多次的情况，因为同一个数字可以再下一轮递归中进行选取），如果同一轮递归选取了两个相同的值，刚好后面的几轮递归的数字是一样的话，就会产生重复的解。另外的话，为了避免选取重样的值，可以传入index作为下轮开始选取的起点，避免重读的同时还做到了剪枝。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外再提到一点就是这里如果顺序是按照从小到大遍历，如果left已经小于当前可选值，可以直接return，这也算一种剪枝。 代码12345678910111213141516171819202122232425262728class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; container,int index){ if(left==0){ ans.push_back(container); return; } //这里是防止每轮选取中避免选到相同的数字，除了，大于等于0之外， int pre = 0; for(int i = index;i&lt;candi.size();++i){ if(left&gt;=candi[i]&amp;&amp;candi[i]!=pre){ pre = candi[i]; container.push_back(candi[i]); traverse(left-candi[i],candi,container,i+1); container.pop_back(); } else if(left&lt;candi[i])return; } } vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp,0); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想分析一下这里的复杂度，考虑最坏情况，没有相等的数字，并且没有一种情况可以达成有效解（target很大），每条路径走到底应该要2^n倍时间复杂，从最初的遍历算一共有n个数可供选择，当然到最后由于index传入的剪枝，时间会小于2^n，总的上限应该是O(n*2^n),系数应该小于1，这个时间复杂度大于O(nlogn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空间复杂度就是O(n),取的是递归最大深度。","link":"/2020/09/10/leetcode-0910/"},{"title":"9月11号leetcode每日一题","text":"原题链接: 组合总和 III 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leetocde这几天感觉是要弄一个组合周…，总的来说还是换汤不换药，问题的关键在于去除重复的组合，重点是题目中说明不会出现重复的数字，这样就很简单了，递归函数包括两个参数，一个是剩余选取次数，一个是剩余选取大小，只有两者都为0时才能将结果push进最终答案，感觉实在没有什么好说的，确实太水了。。。 代码1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,int num_left,int last,vector&lt;int&gt;&amp; target){ if(left==0||num_left==0){ if(!left&amp;&amp;!num_left)ans.push_back(target); return; } for(int i = last+1;i&lt;=9;++i){ if(num_left&gt;=i){ target.push_back(i); traverse(left-1,num_left-i,i,target); target.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { vector&lt;int&gt; temp; traverse(k,n,0,temp); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里最后的时间效率超过了99%，主要是从大到小遍历进行了剪枝，按照选取次数进行时间复杂度分析，一共有C(9,k)条路径选择，每条最大深度为k，时间复杂度为O(C(9,k)*k),当然因为这里进行了剪枝，实际上会更小。空间复杂度，临时数组大小为k,栈的最大深度为k，所以空间复杂度为O(k)（终于赶在上飞机前写完了2333）。","link":"/2020/09/11/leetcode-0911/"},{"title":"9月12号leetcodeme每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题就没有什么好说的，经典层序遍历，记录每层的一个size值即可。没有什么价值可言…（就随便贴一下代码好了233） 代码123456789101112131415161718192021class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { vector&lt;double&gt; ans; queue&lt;TreeNode*&gt; q; if(root==nullptr)return ans; q.push(root); while(!q.empty()){ int cnt = q.size();double sum = 0; for(int i = 0;i&lt;cnt;++i){ TreeNode* temp = q.front(); sum+=temp-&gt;val; if(temp-&gt;left)q.push(temp-&gt;left); if(temp-&gt;right)q.push(temp-&gt;right); q.pop(); } ans.push_back(sum/cnt); } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度感觉就O（n），n为树中所有节点的数量，今天的博客就先水一水，看楼教主打比赛去了。","link":"/2020/09/11/leetcode-0912/"},{"title":"9月14号leetcode每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很经典的题目，对于熟练一定的模板还是很有作用的，但刚开始的时候并没有看清楚题目，差点写成了前序遍历，这里就纯当练手了吧，做过太多遍了。。。 代码123456789101112131415vector&lt;int&gt; inorderTraverse(TreeNode* root){ vector&lt;int&gt; ans; vector&lt;TreeNode*&gt; stk; TreeNode* curr = root; while(curr||!stk.empty()){ while(curr){ stk.push(curr); curr = curr-&gt;left; } curr = stk.top(); ans.push_back(curr-&gt;val); curr = curr-&gt;right; stk.pop(); }} 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度很显然是树中所有节点的数量n，O（n）。空间复杂度就是栈所占用的空间，这里应该是与树的最大高度成正比O（h）。","link":"/2020/09/14/leetcode-0914/"},{"title":"9月16号leetcode每日一题","text":"原题链接: 翻转二叉树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这道题属于那种有手就行的，但是将核心递归函数融合在返回主函数中还是比较巧妙的，要翻转这个树，就先翻转他的左右子树，之后在把两边指针进行交换。递归边界就是遇到root为空。虽然简单，但是题目还是比较典型的。 代码1234567891011class Solution {public: TreeNode* invertTree(TreeNode* root) { if(!root)return root; auto l = invertTree(root-&gt;left); auto r = invertTree(root-&gt;right); root-&gt;left = r; root-&gt;right = l; return root; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里时间复杂度是树中节点的个数，因为我们要对每个点及其构成的子树进行翻转，空间复杂度就是栈的最大深度，这里应该是树的高度。","link":"/2020/09/16/leetcode-0916/"},{"title":"9月17日leetcod每日一题","text":"原题链接: 冗余连接 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题其实在七月的每日一题中已经出现，当时也是一次就自己写出来了。这次的思路和上次的差不太多，算是利用一点并查集的思想，将每个点父节点存储到一个数组之中，正常情况下，除了根节点没有父节点之外，其他节点有且只有一个父节点，但是多添加一条边之后，可能出现两种情况。 第一种就是每个节点都父节点，这样可以肯定的是多出来的边肯定是指向根节点的那条边，这时候图中必定存在一个环，所以所以我么们应该找到这个环，严格来说去除这个环中的任意一条边都满足条件，所以我们应该找出那条最后出现的边进行删除。 第二种情况就是同一条边出现了多个父节点，此时情况相对来说比较简单，答案是发生冲突的两条边之一。注意这里为什么说是之一，因为可能不符合条件的边是先出现的那条边。所以还是要检测是否有环，如果没有，则说明开始那条边应该被保留。 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int n = edges.size(); vector&lt;int&gt; ans; vector&lt;int&gt; pre(n+1,0);//记录每个点的父节点 vector&lt;bool&gt; book(n+1,false); vector&lt;vector&lt;int&gt;&gt; cdd; for(auto edge:edges){ if(pre[edge[1]]){cdd.push_back({pre[edge[1]],edge[1]});cdd.push_back(edge);continue;}//如果已经存在父节点，但是仍然有以该点作为出度的边的话，就将其加入到冗余集合里面去 pre[edge[1]]=edge[0]; } if(!cdd.empty()){ int temp = cdd[0][1];//第一条边的出度点 //这里之所以这么做是因为最开始出现的边不一定是有效的边。 while(true){ if(book[temp]){ if(temp)return cdd[0]; return cdd[1]; } book[temp]=true; temp = pre[temp]; } } //如果每个点都父节点，说明多出来的边肯定落在了 int target = 1; while(true){ if(book[target])break; book[target]=true; target = pre[target]; } book.resize(n+1,false); while(!book[target]){ book[target]=true; target = pre[target]; } for(int i =n-1;i&gt;=0;i--){ if(book[edges[i][0]]&amp;&amp;book[edges[i][1]]){ans=edges[i];break;} } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这里1并没有说是根节点，所以有可能出现从一条路径网上回溯的时候走过了一段并不在环内的部分，所以只有在出现重复的点的时候才能确定该点在环路内部，然后再从环路内部开始进行回溯（类似于并查集中所说的找帮派），将所有在环中的点标记，然后从输入尾部开始进行遍历，如果两个顶点都属于环内顶点，则返回该边。时间复杂度首先遍历所有边是O(m)，然后判断是否有环，时间复杂度最差为O（h）为数的高度，整体时间复杂度还是O(M),空间复杂度为O（N），N为图中节点的个数。","link":"/2020/09/17/leetcode-0917/"},{"title":"9月7号leetcode每日一题","text":"原题链接:前k个高频元素 思考过程首先最直白的方法肯定是统计数字出现频率，然后排序选出频率最高的前K个数字。但是既然会用到排序，那么复杂度就会来到 O(nlogn),不太符合题目的要求。这时候很自然的就想到了快速的partition来进行划分，划分出来频率高的一边有k个即可。另外一种想法就是(纯靠自己乱想的)，因为题目保证答案唯一，所以频率最高的前K个数字是确定的，使用map计数，然后每轮对元素数目每次减去1，这样某一轮过后，必定会在map中只剩K个元素，最后push到结果即可。 自行思考的方法1234567891011121314151617181920vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int,int&gt; mp; for(auto&amp; item:nums){ ++mp[item]; } int cnt = mp.size(); while(cnt&gt;k){ for(auto&amp; item:mp){ item.second--; if(item.second==0){ --cnt; } } } vector&lt;int&gt; ans; for(auto&amp; item:mp){ if(item.second&gt;0)ans.push_back(item.first); } return ans; quick sort12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) { int picked = rand() % (end - start + 1) + start; swap(v[picked], v[start]); int pivot = v[start].second; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (v[i].second &gt;= pivot) { swap(v[index + 1], v[i]); index++; } } swap(v[start], v[index]); if (k &lt;= index - start) { qsort(v, start, index - 1, ret, k); } else { for (int i = start; i &lt;= index; i++) { ret.push_back(v[i].first); } if (k &gt; index - start + 1) { qsort(v, index + 1, end, ret, k - (index - start + 1)); } } } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v: nums) { occurrences[v]++; } vector&lt;pair&lt;int, int&gt;&gt; values; for (auto&amp; kv: occurrences) { values.push_back(kv); } vector&lt;int&gt; ret; qsort(values, 0, values.size() - 1, ret, k); return ret; }}; minimum heap1234567891011121314151617181920212223242526272829303132333435class Solution {public: /* 提醒一下，这里定义成员函数的话要尾置const,定义priority的cmp函数都要注意这一点。 */ static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) { return m.second &gt; n.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp); for (auto&amp; [num, count] : occurrences) { if (q.size() == k) { if (q.top().second &lt; count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector&lt;int&gt; ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; }}; 总结总的来说，快排的思路最好想，平均时间复杂度也只有O(n)，虽然最坏是O（n^2），小根堆则是利用了数据结构的特点，但是其时间复杂度并不太好O（nlogk），我自己想的方法就参考一下吧（其实有点像快乐模拟23333）。","link":"/2020/09/07/leetcode-daily-0907/"},{"title":"9月13号leetcode每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题一开始肯定想的是使用dfs，外加bool型数组记录是否被选取，但是发现我自己原来写的并没有剪枝，但是时间效率还不错…看了题解，发现也是简单dfs加回溯。。。无语，那就这样写吧，这样的话感觉这道题就没有什么意义了，纯粹考察熟练度。 代码1234567891011121314151617181920212223242526272829303132class Solution {public: bool ans = false; int direct[4][2]={ {1,0},{0,1},{-1,0},{0,-1} }; bool book[200][200]={false}; void dfs(const string&amp; word,const vector&lt;vector&lt;char&gt;&gt;&amp; target,int index,int x,int y){ if(ans)return;//部分剪枝 if(index+1==word.size()){ans=true;return;} for(int i=0;i&lt;4;i++){ int tx= x+direct[i][0],ty = y+direct[i][1]; if(tx&lt;0||tx&gt;=target.size()||ty&lt;0||ty&gt;=target[0].size())continue; if(!book[tx][ty]&amp;&amp;target[tx][ty]==word[index+1]){ book[tx][ty]=true; dfs(word,target,index+1,tx,ty); book[tx][ty]=false; } } } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { for(int i=0;i&lt;board.size();i++){ for(int j=0;j&lt;board[0].size();++j){ if(board[i][j]==word[0]){ book[i][j]=true;dfs(word,board,0,i,j);book[i][j]=false; } } } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里感觉时间复杂度是O（MNL）,和官方题解不一样这里没有计算条件分支，感觉这里的条件分支可一并到一起，加不加那个指数感觉无关紧要。空间复杂度很明显，栈的深度最大是L，bool型数组大小为M*N。","link":"/2020/09/13/leetcode-o913/"},{"title":"9月15号leetcode每日一题","text":"原题链接 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话，这道题还是有一定的思考量的，刚开始想的是建立每行每列以及每个cell，之后就是把空的点push到一个队列里面，如果当前点可以进行填写（意思就是说其他8个数已经确定），就将节点pop出去，如果不能进行填写，pop出去之后就再push进入队尾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样其实有一个问题就是有的数独他可能不会出现上述情况，比如说有的数读就是要你猜测某个点的值，你具有试错机会，所以说上面那种算法不仅耗时比较长，而且有可能会进入死循环。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们在这里采用的是题解中的方法，采用的是dfs式的递归方法，如果遇到冲突，还可以进行回溯试错。并且更进一步的还有bitset方法，占用空间较小（虽然最后出来的结果好像不是特别好2333） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution {private: vector&lt;bitset&lt;9&gt;&gt; rows; vector&lt;bitset&lt;9&gt;&gt; cols; vector&lt;vector&lt;bitset&lt;9&gt;&gt;&gt; cells;public: bitset&lt;9&gt; status(int x,int y){ return ~(rows[x]|cols[y]|cells[x/3][y/3]); } //返回有效位置bitset应该是没有问题的。 pair&lt;int,int&gt; getNext(vector&lt;vector&lt;char&gt;&gt;&amp; board){ pair&lt;int,int&gt; ret; int min_cnt = 10;//代表10中可能选择的方案，我们这里选择的是最小选择数目的那个点 for(int i = 0;i&lt;9;++i){ for(int j = 0;j&lt;9;++j){ if(board[i][j]=='.'){ auto temp = status(i,j); if(temp.count()&lt;min_cnt){ ret = {i,j}; min_cnt = temp.count(); } } } } return ret; } //每次返回下一个最少选择的位置没有问题 void fillNum(int x,int y,int n,bool flag){ rows[x][n] = flag ? 1 : 0; cols[y][n] = flag ? 1 : 0; cells[x/3][y/3][n] = flag ? 1 : 0; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int cnt){ // printf(&quot;%d\\n&quot;,cnt); if(cnt == 0)return true; auto next = getNext(board); auto bits = status(next.first,next.second); for(int i = 0;i&lt;9;++i){ if(bits.test(i)){ //说明这个点可以选，选择这个点之后更新各个数组的状态，然后进行下一轮的递归 fillNum(next.first,next.second,i,true); board[next.first][next.second] = i + '1'; if(dfs(board,cnt-1))return true; board[next.first][next.second] = '.'; fillNum(next.first,next.second,i,false); } } return false; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { rows.resize(9); cols.resize(9); cells.resize(3,vector&lt;bitset&lt;9&gt;&gt;(3)); int cnt = 0; for(int i = 0;i&lt;9;++i){ for(int j = 0;j&lt;9;++j){ if(board[i][j] == '.'){++cnt;continue;} int n = board[i][j] - '1'; rows[i] |= (1&lt;&lt;n); cols[j] |= (1&lt;&lt;n); cells[i/3][j/3] |= (1&lt;&lt;n); } } // printf(&quot;Initialization is okay.\\n&quot;); dfs(board,cnt); }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里比较精妙的就是设置了一个找出了一个可选数字最少的空白点，这样出错几率相对来说会更小。getNext函数，对全表进行扫描来选出目标点，而找到目标的方法就是对空点进行剩余可选个数计算，这就是status函数的作用。然后每次我们遍历一个点选择一个数的时候，应该要对相应的行，列以及块进行更新。这就是fillNum的功能，dfs形式选择参数为剩余的空白点。这里有一个小技巧，如果有一个路径走通了，其他路径就不用走了，所以返回类型可以设置为bool，返回为true的时候就也直接return true,以达到剪枝的目的。时间复杂度和空间复杂度，因为这里数独的维度是固定死的，所以都是常数级别。","link":"/2020/09/15/leetocde-0915/"},{"title":"记录一次线上环境配置以及测试","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近几天再忙学校自动填表的线上项目部署，遇到了不少问题，为防止以后忘记，在此特地记录一下。 mysql插入操作报错报错信息为 1$:incorrect value .......... for column 1 &nbsp;&nbsp;&nbsp;&nbsp;中间省略号为一串乱码，一般这种问题就和编码相关，去查了一下，mysql默认编码为latin1,插入中文数据会报错，需要对表和数据库的编码进行修改。&nbsp;&nbsp;&nbsp;&nbsp;去stackoverflow上面查询对应的解决方案 12345678910111213141516171819#For databaseALTER DATABASE databasename CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;#For tableALTER TABLE tablename CONVERT TO CHARACTER SET utfmb4 COLLATE utf8mb4_unicode_ci;#For columnALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; &nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，mysql的unicode编码为3个字节，所以得将字符编码设置为utf8mb4(话说我本地的mysql好像版本新一些8.0，不用改编码也能跑,centos7给👴爬)。 &nbsp;&nbsp;&nbsp;&nbsp;这里出现了一个COLLATE字段，可以简单理解为字段组织排序的方式，ci尾缀代表case insensitive。更详细的可以参考掘金的这篇博客 &nbsp;&nbsp;&nbsp;&nbsp;修改字符集之后插入成功 ssh远程连接+debug过程&nbsp;&nbsp;&nbsp;&nbsp;按理来说这个其实比较简单，就是按照 1$:ssh username@ip_address 初次输入密码，在本地生成公钥私钥文件 1ssh-keygen -t rsa -b 4096 更多参数可以查手册，默认是2048位的。之后通过scp命令传输文件将公钥传输到.ssh文件夹下面，并且传输内容到authorized_keys中。 1scp local/path/.ssh/id_rsa.pub username@ip_address: remote/path/.ssh/uploaded_file_name On remote side 123cat ~/.ssh/uploaded_file &gt;&gt; ~/.ssh/authorized_keyschmod 700 ~/.ssh/chmod 600 ~/.ssh/* chmod stands for change mod, which means changes to different access level.&nbsp;&nbsp;&nbsp;&nbsp;突然写起英文2333，这上面的步骤都很简单，但是在我原来的PC上都不管用，最后的原因是因为我的$HOME变量中含有中文。所以问题的解决方案就是修改中文用户名为英文，具体过程就不再啰嗦了。&nbsp;&nbsp;&nbsp;&nbsp;大致就是注销当前账号，使用administrator登录，修改用户文件夹和注册表中的路径名字，在切换回来。就可以不用使用密码远程连接主机了。 额外啰嗦为了使主机更加安全，可以禁用密码验证，修改/etc/ssh/sshd_config文件，将password authentication修改为false,记得修改之前备份文件. 123sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak#centos7使用这中格式的指令systemctl restart sshd 本来还想把cron定时运行脚本以及grep查找指令也写一下，时间太晚了就先写这么多了。","link":"/2020/09/08/online-test/"}],"tags":[{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"leftmost prefix index","slug":"leftmost-prefix-index","link":"/tags/leftmost-prefix-index/"},{"name":"depth-first-search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"combination","slug":"combination","link":"/tags/combination/"},{"name":"depth first search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"cut branch","slug":"cut-branch","link":"/tags/cut-branch/"},{"name":"breadth-first-search","slug":"breadth-first-search","link":"/tags/breadth-first-search/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"inorder traverse","slug":"inorder-traverse","link":"/tags/inorder-traverse/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"grapth","slug":"grapth","link":"/tags/grapth/"},{"name":"disjoint-set","slug":"disjoint-set","link":"/tags/disjoint-set/"},{"name":"min heap","slug":"min-heap","link":"/tags/min-heap/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"},{"name":"dynamic programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"bit operation","slug":"bit-operation","link":"/tags/bit-operation/"},{"name":"hashtable","slug":"hashtable","link":"/tags/hashtable/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"leetcode-daily","slug":"leetcode-daily","link":"/categories/leetcode-daily/"},{"name":"leetocde-daily","slug":"leetocde-daily","link":"/categories/leetocde-daily/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}]}