{"pages":[],"posts":[{"title":"My_First_Post","text":"第一次部署总算是把页面部署好了(django写的因为自己不会前端+审美强迫症暂时留坑)，虽然还有很多不完善的地方，但是暂时来说基本上能用就行了，后期可能会添加评论，分享以及广告之类的功能&amp;&amp;备案&amp;&amp;申请新的域名之类的功能。 碎碎念 作为一名cs学生，以后博客应该还是偏向技术性的，目前已经想好的是将leetcode每日一题题解和代码发布在博客。一些读书笔记，比如CCIA，可能会学习的golang，unix programming interface之类的（书买太多了2333） 联系PO一下联系方式吧，万一哪天我就有读者了呢hhhh 邮箱：woshizhansen@gmail.com qq: 1369905261 1printf(&quot;Keep coding and move forward!\\n&quot;);","link":"/2020/09/06/My-First-Post/"},{"title":"Trie字典树实现","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这个拖了很久了，今天总算有机会把字典树的实现自己写一遍了，毕竟这么好的数据结构放着不用确实有些可惜。一次建树，多次查询。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和普通的树结构不一样，一般的树结构都是 12345template&lt;class T&gt;struct TreeNode{ T value; TreeNode *children[NUM];}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是字典树的结构是这样的 1234struct TrieNode{ bool isENnd; TrieNode* next[26];}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大概意思就是说，我们可以通过父节点来得知他所有子节点的值，如果子节点中存在该字符，那么节点就不为空。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过代码来讲述功能可能更为合适。 12345678910111213141516171819202122232425262728293031323334353637383940414243clas Trie{private: bool isEnd; Trie* next[26];public: Trie(){ isEnd = false; memset(next,nullptr,sizeof(next)); } void insert(string word){ Trie* node = this; for(char&amp; c: word){ if(node-&gt;next[c-'a']==nullptr){ node-&gt;next[c-'a'] = new Trie(); } node = node-&gt;next[c-'a']; } node-&gt;isEnd = true; } bool search(string&amp; word){ Trie* node = this; for(char&amp; c:word){ if(node-&gt;next[c-'a']==nullptr){ return false; } node = node-&gt;next[c-'a']; } return node-&gt;isEnd; } bool startWith(string&amp; prefix){ Trie* node = this; for(char&amp; c:prefix){ if(node-&gt;next[c-'a']==nullptr){ return false; } node = node-&gt;next[c-'a']; } return true; }} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入过程其实就是从头结点开始遍历，如果当前单词中的字母在字典树中未出现，则新建相应的节点。另外就是查找和检查前缀，两者的区别主要在于前缀匹配不需要检查最后的节点是否是字符结尾。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好像也没啥总结的，算是完成了之前的一个遗留任务吧，吐槽一句，work life balance真的很重要，今天算是半年以来第一次打球，体力真的差好多。。。","link":"/2020/09/21/Trie/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/06/hello-world/"},{"title":"面试复盘(联合索引)","text":"preface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天一面感觉还算比较典型，面试官也没有为难的意思，问的题目大多都比较典型，主要类型是数据库和网络，然后问到了一个联合索引的问题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致意思是在a,b,c三个列上建立联合索引，然后问 12SELECT * FROM users WHERE a&gt;A AND b&gt;B; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个查询语句是否会经过索引。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正确答案是会经过索引，这里所涉及到的一个知识点就是最左前缀匹配。 索引及其性能优化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本好处： 首先就是会使查找变快，这种加速在进行多表连接的时候尤为明显。 索引会显著减少磁盘IO次数，并且如果搜查结果只包含索引列，那么查找甚至都不会检索数据行而是直接读取索引。请注意这一点，如果你的所有数据列都建了索引，那没你的任何一次查找都会走索引，就不会读磁盘（即人们常说的回表）。\\ 索引分类主要分为四种： non unique unique Primary Key Fulltext Index(全文索引) 增加或者删除索引的语法这里就不说了，很简单的，可以自己去查，接下来重点说一下show index这个语句中每个字段的具体意思。 1SHOW INDEX FROM CountryLanguage; field meaning Table represent table name Non-unique if it is a unique index or not Key name alias to this index seq_in_index 联合索引的位置（如果是单个索引的话就是1） Colun_name indexed column name collation 每个collation都归属于一个字符集，每个字符集合都至少有一个collation,collation的作用就是帮助数据库进行排序 cardinality unique value in this column sub_part 如果该列只有部分建立索引，则显示被索引部分的下表，全部都有索引的话则显示null Packed Indiacate how the key is packed.Null if it is not NULL 如果该列可能含有null值的话就显示yes，如果不含有的话就为空 Index_type index method used Index_comment 创建index的时候你如果加了注释就有这个字段 comment 额外的注释信息，例如disable,老实说这个没看懂2333 visible if the optimizer can see the index Using Index使用索引的时候有一些要注意的点： indexed column最好是非NULL的，检索时对NULL进行比较需要额外的判断 不要过度使用索引，首先添加索引是需要消耗空间的，并且如果索引太多的话，每次对表进行更新都需要花费大量的时间和资源去维护已有的索引。 老生常谈的，索引列的值要是大部分都是一致的，索引的效率就会接近于table scan 选择合适的索引类型，比如说某一列是enum类型的话，就最好选择non_unique索引类型 减少建立索引字段的长度，就比如说mysql会在内存里面缓存一些rows来避免过多的磁盘I/O，如果选择整个列的字段作为索引的话，所占空间相对来说就会变较大，所以我们可以选择部分字段来建立索引。 不要建立互有重叠的索引，比如说两个联合索引初始列是相同的，因为最左前缀匹配原则。 Indexing column Prefixes使用整个字段进行索引建立会有如下三个缺点： 需要从磁盘中读取更多的信息 较长的值需要花费较长的时间去比较 index cache会因为字段太长而只能存储比较少的字段，导致优化效率变低。 所以我们可以使用如下语法来建立prefix索引 1234CREATE TABLE t( name char(255), INDEX (name(25))); 但是这样又会引发一个问题，字段如果太短，会造成index字段差异不够大，就是说name前多少个字符相差都不大，这样的话就会降低索引的性能，所以我们应该在长度和uniqueness之间做一个折中。我们可以使用如下语句进行比较 1234567891011121314151617SELECT COUNT(*) AS 'Total Rows', COUNT(DISTINCT name) AS 'Distinct Values', COUNT(*) - COUNT(DISTINCT name) AS 'Duplicate Values'FROM t;SELECT COUNT(DISTINCT LEFT(name,n)) AS 'Distinct Prefix Values', COUNT(*) - COUNT(DISTINCT LEFT(name,n)) AS 'Duplicate Prefix Values'FROM t; 通过不断调整n的大小来对两组数据进行对比，来进行一个折中。还有一点需要注意的是，如果你对primary key或者unique key进行prefix indexing 的时候，要确保前缀也是不相同的，否则就要改变index的类型。 Leftmost Index Prefixes最左前缀匹配可以减少重复的索引建立，比如说面试题中的a,b,c作为composite index，查询时仅使用a,b是使用到index的。具体是否经过索引可以使用explain进行检测。 Fulltext Indexes注意事项： 全文索引目前只有MyISAM 数据类型只能是char,varchar或者text类型，不能是binary 全文索引是case insensitive的。创建全文索引的语法 12345678910CREATE TABLE t (name CHAR(40), FULLTEXT (name));ALTER TABLE t ADD FULLTEXT name_idx (name);ALTER TABLE t DROP INDEX name_idx;CREATE FULLTEXT INDEX name_idx ON t (name);DROP INDEX name_idx ON t; 全文索引不支持前缀索引，如果使用前缀，mysql会忽略这个请求 因为全文索引不支持前缀索引，所以全文索引也不支持最左前缀匹配，要使用不同的组合的话，要分别建立索引 使用示例： 1SELECT * FROM t WHERE MATCH(name) AGAINST('Wendell'); 这条语句用来检索，name列中含有Wendell的字段。记住，要是对不同列或者组合进行全文索引查询，需要分别建立索引。 本文参考了 Index Optimization and Index Usage以及mysql使用手册。","link":"/2020/09/14/interview-review/"},{"title":"9月8号leetcode每日一题","text":"原题链接 组合 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题刚拿到一看就比较典型，组合选k个数字，应该可以用dfs解决。但是这道题要求的是组合，如果按照循环遍历选一个再用bool数组记录选取情况的话，会产生很多不必要的递归路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此要确定每个组合只有一个排列会push到最终结果，方法就是规定一个顺序即可，这里就规定递增顺序即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是做出来之后效率比较低下，应该是没有进行剪枝，仔细一想，每次要求遍历开始的部分直接从已有数字+1开始（数组为空时取1即可），修改之后最大时间缩短为十分之一。然而超过人数占比并不理想，所以在想了想，要是当前剩余可遍历元素少于所需元素个数，好像也可以直接返回，最后运行结果16ms,超过94%。 dfs递归代码12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void dfs(int left,int n,vector&lt;int&gt;&amp; target){ if(left==0){ ans.push_back(target); return; } int i = target.empty()? 1 :target.back()+1; int bound = n - left + 1; for(;i&lt;=bound;++i){ target.push_back(i); dfs(left-1,n,target); target.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { //注意不是排列是组合，所以要想个办法使得每个组合的排列只出现一次， //好像规定组合内数字递增即可，递增算是同一组合的唯一排序 vector&lt;int&gt; temp; dfs(k,n,temp); return ans; }}; 非递归二进制组合代码思路这里是官方题解中给出的思路，意思就是选取k个数字，转换为一个n位2进制数应该是k个1，n-k个0，我们要找到一种从最低k位全1到最高k位全1的变换方法，这种方法很好理解，就是先最高位加1，然后整体从高到低都加1。一轮过后最高位加1，再开始。**注意代码实现使用了一点小trick，即在尾部多添加一个n+1的数字，其实在1到n之外的数字都行，仔细品味2333**。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { // 初始化 // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k] // 末尾加一位 n + 1 作为哨兵 for (int i = 1; i &lt;= k; ++i) { temp.push_back(i); } temp.push_back(n + 1); int j = 0; while (j &lt; k) { ans.emplace_back(temp.begin(), temp.begin() + k); j = 0; // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t] while (j &lt; k &amp;&amp; temp[j] + 1 == temp[j + 1]) { temp[j] = j + 1; ++j; } // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置 ++temp[j]; } return ans; }}; 总结题目算是在普通dfs上的一个变式，时间效率上的pogai也再次提醒我们剪枝的重要性，另外利用二进制数进行模拟这种方法还是比较难想到的，算是拓宽视野了。 碎碎念今天终于收到字节面试通知了，有点开心又有点紧张，总之努力准备，加油！","link":"/2020/09/08/leetcode-0908/"},{"title":"9月9日leetcode每日一题","text":"原题链接: 组合总和 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说句题外话，这道题和昨天的那道组合数基本一样，只不过要自己额外做点处理，甚至在剪枝的要求上还不如昨天那道题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拿到这道题的第一想法就是我先用大的数去减这个target，减不动了再用小一点的数字。这一点很好理解，相当于将所有可行解按照解的长度由小到大排列。但是这里没有保证数组有序，所以预先排序即可。但是第一次实现的时候，发现有重复组合，消除重复组合的方法昨天的博客里面已经提到，限定一种顺序即可，这里我们按照从大到小的顺序，因为可以重复选取元素，所记得选元素的时候可以是小于等于。 代码123456789101112131415161718192021222324class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; curr){ if(left==0){ ans.push_back(curr); return; } for(int i = candi.size()-1;i&gt;=0;--i){ if(left&gt;=candi[i]&amp;&amp;(curr.empty()||curr.back()&gt;=candi[i])){ curr.push_back(candi[i]); traverse(left-candi[i],candi,curr); curr.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp); return ans; }}; 总结这里要注意一点要先判定curr是否为空再判断curr.back()与candi[i]的大小关系，不然会出现访问不存在元素的未定义行为，所以书本里面写的很有道理，先检查边界有效性，再检查内容。另外提一句，这里时间效率已经超过90%，进一步剪枝的话就把curr.empty()和curr.back()&gt;=candi[i]这个判定拉出来，直接让i从符合条件的位置开始遍历，或者再在traverse中添加一个index参数，记录上次选取的index，这次选取就从index（想想为什么不是index-1?）开始递减遍历。","link":"/2020/09/09/leetcode-0909/"},{"title":"9月10号leetcode每日一题","text":"原题链接: 组合总和|| 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天还是组合类型题目，无语…唯一的区别就是每个数字之可以选取一次，并且可选数字中会出现重复的数字，所以这道题最大的难点在于去重。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要去重就要分析可能出现重复的情况，举个例子来自说，target是11，candidates是[1,10,10]，这样就会出现重复的解，为了避免这样的情况，需要做的就是在每一轮递归的过程中不要选取重复的值（这里的意思并不是说排查了一个数字选多次的情况，因为同一个数字可以再下一轮递归中进行选取），如果同一轮递归选取了两个相同的值，刚好后面的几轮递归的数字是一样的话，就会产生重复的解。另外的话，为了避免选取重样的值，可以传入index作为下轮开始选取的起点，避免重读的同时还做到了剪枝。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外再提到一点就是这里如果顺序是按照从小到大遍历，如果left已经小于当前可选值，可以直接return，这也算一种剪枝。 代码12345678910111213141516171819202122232425262728class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; container,int index){ if(left==0){ ans.push_back(container); return; } //这里是防止每轮选取中避免选到相同的数字，除了，大于等于0之外， int pre = 0; for(int i = index;i&lt;candi.size();++i){ if(left&gt;=candi[i]&amp;&amp;candi[i]!=pre){ pre = candi[i]; container.push_back(candi[i]); traverse(left-candi[i],candi,container,i+1); container.pop_back(); } else if(left&lt;candi[i])return; } } vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp,0); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想分析一下这里的复杂度，考虑最坏情况，没有相等的数字，并且没有一种情况可以达成有效解（target很大），每条路径走到底应该要2^n倍时间复杂，从最初的遍历算一共有n个数可供选择，当然到最后由于index传入的剪枝，时间会小于2^n，总的上限应该是O(n*2^n),系数应该小于1，这个时间复杂度大于O(nlogn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空间复杂度就是O(n),取的是递归最大深度。","link":"/2020/09/10/leetcode-0910/"},{"title":"9月11号leetcode每日一题","text":"原题链接: 组合总和 III 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leetocde这几天感觉是要弄一个组合周…，总的来说还是换汤不换药，问题的关键在于去除重复的组合，重点是题目中说明不会出现重复的数字，这样就很简单了，递归函数包括两个参数，一个是剩余选取次数，一个是剩余选取大小，只有两者都为0时才能将结果push进最终答案，感觉实在没有什么好说的，确实太水了。。。 代码1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,int num_left,int last,vector&lt;int&gt;&amp; target){ if(left==0||num_left==0){ if(!left&amp;&amp;!num_left)ans.push_back(target); return; } for(int i = last+1;i&lt;=9;++i){ if(num_left&gt;=i){ target.push_back(i); traverse(left-1,num_left-i,i,target); target.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { vector&lt;int&gt; temp; traverse(k,n,0,temp); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里最后的时间效率超过了99%，主要是从大到小遍历进行了剪枝，按照选取次数进行时间复杂度分析，一共有C(9,k)条路径选择，每条最大深度为k，时间复杂度为O(C(9,k)*k),当然因为这里进行了剪枝，实际上会更小。空间复杂度，临时数组大小为k,栈的最大深度为k，所以空间复杂度为O(k)（终于赶在上飞机前写完了2333）。","link":"/2020/09/11/leetcode-0911/"},{"title":"9月12号leetcodeme每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题就没有什么好说的，经典层序遍历，记录每层的一个size值即可。没有什么价值可言…（就随便贴一下代码好了233） 代码123456789101112131415161718192021class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { vector&lt;double&gt; ans; queue&lt;TreeNode*&gt; q; if(root==nullptr)return ans; q.push(root); while(!q.empty()){ int cnt = q.size();double sum = 0; for(int i = 0;i&lt;cnt;++i){ TreeNode* temp = q.front(); sum+=temp-&gt;val; if(temp-&gt;left)q.push(temp-&gt;left); if(temp-&gt;right)q.push(temp-&gt;right); q.pop(); } ans.push_back(sum/cnt); } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度感觉就O（n），n为树中所有节点的数量，今天的博客就先水一水，看楼教主打比赛去了。","link":"/2020/09/11/leetcode-0912/"},{"title":"9月14号leetcode每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很经典的题目，对于熟练一定的模板还是很有作用的，但刚开始的时候并没有看清楚题目，差点写成了前序遍历，这里就纯当练手了吧，做过太多遍了。。。 代码123456789101112131415vector&lt;int&gt; inorderTraverse(TreeNode* root){ vector&lt;int&gt; ans; vector&lt;TreeNode*&gt; stk; TreeNode* curr = root; while(curr||!stk.empty()){ while(curr){ stk.push(curr); curr = curr-&gt;left; } curr = stk.top(); ans.push_back(curr-&gt;val); curr = curr-&gt;right; stk.pop(); }} 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度很显然是树中所有节点的数量n，O（n）。空间复杂度就是栈所占用的空间，这里应该是与树的最大高度成正比O（h）。","link":"/2020/09/14/leetcode-0914/"},{"title":"9月16号leetcode每日一题","text":"原题链接: 翻转二叉树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这道题属于那种有手就行的，但是将核心递归函数融合在返回主函数中还是比较巧妙的，要翻转这个树，就先翻转他的左右子树，之后在把两边指针进行交换。递归边界就是遇到root为空。虽然简单，但是题目还是比较典型的。 代码1234567891011class Solution {public: TreeNode* invertTree(TreeNode* root) { if(!root)return root; auto l = invertTree(root-&gt;left); auto r = invertTree(root-&gt;right); root-&gt;left = r; root-&gt;right = l; return root; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里时间复杂度是树中节点的个数，因为我们要对每个点及其构成的子树进行翻转，空间复杂度就是栈的最大深度，这里应该是树的高度。","link":"/2020/09/16/leetcode-0916/"},{"title":"9月17日leetcod每日一题","text":"原题链接: 冗余连接 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题其实在七月的每日一题中已经出现，当时也是一次就自己写出来了。这次的思路和上次的差不太多，算是利用一点并查集的思想，将每个点父节点存储到一个数组之中，正常情况下，除了根节点没有父节点之外，其他节点有且只有一个父节点，但是多添加一条边之后，可能出现两种情况。 第一种就是每个节点都父节点，这样可以肯定的是多出来的边肯定是指向根节点的那条边，这时候图中必定存在一个环，所以所以我么们应该找到这个环，严格来说去除这个环中的任意一条边都满足条件，所以我们应该找出那条最后出现的边进行删除。 第二种情况就是同一条边出现了多个父节点，此时情况相对来说比较简单，答案是发生冲突的两条边之一。注意这里为什么说是之一，因为可能不符合条件的边是先出现的那条边。所以还是要检测是否有环，如果没有，则说明开始那条边应该被保留。 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int n = edges.size(); vector&lt;int&gt; ans; vector&lt;int&gt; pre(n+1,0);//记录每个点的父节点 vector&lt;bool&gt; book(n+1,false); vector&lt;vector&lt;int&gt;&gt; cdd; for(auto edge:edges){ if(pre[edge[1]]){cdd.push_back({pre[edge[1]],edge[1]});cdd.push_back(edge);continue;}//如果已经存在父节点，但是仍然有以该点作为出度的边的话，就将其加入到冗余集合里面去 pre[edge[1]]=edge[0]; } if(!cdd.empty()){ int temp = cdd[0][1];//第一条边的出度点 //这里之所以这么做是因为最开始出现的边不一定是有效的边。 while(true){ if(book[temp]){ if(temp)return cdd[0]; return cdd[1]; } book[temp]=true; temp = pre[temp]; } } //如果每个点都父节点，说明多出来的边肯定落在了 int target = 1; while(true){ if(book[target])break; book[target]=true; target = pre[target]; } book.resize(n+1,false); while(!book[target]){ book[target]=true; target = pre[target]; } for(int i =n-1;i&gt;=0;i--){ if(book[edges[i][0]]&amp;&amp;book[edges[i][1]]){ans=edges[i];break;} } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这里1并没有说是根节点，所以有可能出现从一条路径网上回溯的时候走过了一段并不在环内的部分，所以只有在出现重复的点的时候才能确定该点在环路内部，然后再从环路内部开始进行回溯（类似于并查集中所说的找帮派），将所有在环中的点标记，然后从输入尾部开始进行遍历，如果两个顶点都属于环内顶点，则返回该边。时间复杂度首先遍历所有边是O(m)，然后判断是否有环，时间复杂度最差为O（h）为数的高度，整体时间复杂度还是O(M),空间复杂度为O（N），N为图中节点的个数。","link":"/2020/09/17/leetcode-0917/"},{"title":"9月18号leetcode每日一题","text":"原题链接: 全排列 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;感觉这道题有点回到了之前一大堆组合题目的那段时间，其实思路还是很明朗的，主要就是怎么去重，其他的就按照常规的dfs+回溯即可。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;个人认为去重的关键在于你在同一个位置上选取了相同的数，但是这个相同的数字处于不同的位置，并且这两个解是相同的。为了避免这种情况，我们可以在每次递归中再设置一个bool数组，用来标记本轮递归中已经出现的值，如果后面的位置中还出现相同的值，那么就直接continue。 代码12345678910111213141516171819202122232425262728293031class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; book;public: //想一想每次递归前后要不要标记 void dfs(int left,vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; target){ if(left==0){ ans.push_back(target); return; } unordered_map&lt;int,bool&gt; mp; for(int i = 0;i&lt;nums.size();++i){ if(book[i]==false&amp;&amp;mp[nums[i]]==0){ book[i] = true;mp[nums[i]] = true; target.push_back(nums[i]); dfs(left-1,nums,target); target.pop_back(); book[i] = false; } } } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { //重点在于去重，然而去重的关键在于确定每一轮选择之中已经选择过的数字不要再次选择。 int n = nums.size(); book.resize(n,false); vector&lt;int&gt; temp; dfs(n,nums,temp); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度在没有重复数字的情况下是O(n!)，空间复杂度，栈深度最大为n,每层栈里面还会开一个map，空间复杂度在最坏得情况下是O(n^2)。 碎碎念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天收到字节的感谢信了，有点意外，因为毕竟就两个问题答得不是特别好，有可能是今天答的时候太随意了还是啥。总之有点不甘,垃圾评审给:older_man:爬（其实实习的原因主要贪字节钱多，但是这种想法可能不是太对，但是可以自由支配一定金钱的感觉确实不错，可以干更多想干的事情）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过这样一来也有好处，就是我有更多时间去捣鼓自己的代码了，下一步应该是把填表代码开源到github，博客开通评论系统， 并且提前把机器学习课程的大作业做好，再按照学长的推荐，跟一个好点的小老板干活。不要气馁，继续认真做好自己的事就好了。","link":"/2020/09/17/leetcode-0918/"},{"title":"leetcode_0919","text":"原题链接: 左叶子之和 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树本身就是一个与递归概念联系紧密的数据结构，所以一般遇到这种问题都可以用递归的方法来解决，不过刚开始没有理清题意，还以为求的是最左边的子节点，结果WA了两次。明白了题意之后在普通dfs之上添加一个参数用于标识是左子节点还是右子节点即可。 代码123456789101112131415161718class Solution {private: int ans = 0; public: void dfs(TreeNode* root,int direct){ if(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;direct==0){ ans+=root-&gt;val; return; } if(root-&gt;left)dfs(root-&gt;left,0); if(root-&gt;right)dfs(root-&gt;right,1); } int sumOfLeftLeaves(TreeNode* root) { if(root==nullptr)return ans; dfs(root,1); return ans; }}; 实际上也可以用层序遍历来写，只不过queue中的元素应该是一个pair，即TreeNode*和int(用于标记当前节点属于左边还是右边即可),具体代码就不po了。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度很显然就是O(N),N为节点个数，相当于说每个节点都跑一遍。空间复杂度最坏情况下为O（N），此时树为链式结构，平均空间复杂度为O（logN）。","link":"/2020/09/19/leetcode-0919/"},{"title":"leetcode_0920","text":"[原题链接: https://leetcode-cn.com/problems/subsets/] 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种回溯类的题目都要写吐了，组合的问题其实也和之前大同小异，这里也可以按照一定顺序，对每一位进行选择与否，然后编写递归函数即可，返回条件应该是长度达到了n,这里的n指的是虚拟的长度，也就是是说，不选择的时候也算一步。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然这道题用动态规划也是可以写的，但是总感觉vector拷贝会花不少时间，而且也不能在循环过程中改变vector的大小，这样会导致迭代器失效。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后还有一种方法就是按二进制位标示选取与否，从全0到全1，一次push到答案中。 代码123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; ans; ans.push_back({}); for(int i:nums){ vector&lt;vector&lt;int&gt;&gt; temp = ans; for(auto&amp; item:temp){ item.push_back(i); } ans.insert(ans.end(),temp.begin(),temp.end()); } return ans; }}; 递归写法。 1234567891011121314151617181920class Solution {private:vector&lt;vector&lt;int&gt;&gt; ans;public: void dfs(int len,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; target){ if(len==nums.size()){ ans.push_back(target); return; } dfs(len+1,nums,target); target.push_back(nums[len]); dfs(len+1,nums,target);; target.pop_back(); } vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; temp; dfs(0,nums,temp); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度的话，解法一的时间复杂度是O（2^N*N）,解释就是N次拷贝，拷贝长度是从1到2^(N-1)。空间复杂度是O（2*N）解法二的时间复杂度和解法一相同,空间复杂的只有O（N）。","link":"/2020/09/20/leetcode-0920/"},{"title":"9月21号leetcode每日一题","text":"原题链接: 二叉搜索树转累加树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很简单的题，二叉搜索树用有个特性就是比他大的节点都在他右边，所以这里使用反向的前序遍历即可。（好像实在想不出来有什么好解释的方法，因为确实没什么思路含量…） 代码12345678910111213141516class Solution {int acc = 0;public: //应该要加一个标签来标记左右路径 void travel(TreeNode* root){ if(root==nullptr)return; travel(root-&gt;right); root-&gt;val+=acc; acc = root-&gt;val; travel(root-&gt;left); } TreeNode* convertBST(TreeNode* root) { travel(root); return root; }}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里就是用acc来记录一个累加的值，按照递归顺序加上所遍历节点的值即可。 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里时间空间复杂度就是常见的树的遍历那种，O（N）时间，O(logN)空间。","link":"/2020/09/21/leetcode-0921/"},{"title":"leetcode_0922","text":"原题链接: 监控二叉树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题目和打家劫舍拿到题目很像，大致就是到每个节点会分不同的情况，比如说本道题中就是是否在该节点安装监控，打家劫舍则是是否在那个节点进行盗窃，每个节点的情况依赖于子节点的状态。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对来说这道题的情况稍微复杂一点，需要记录的状态也随要求来进行变化。首先，每个点可能不会安装监控，这就需要该节点的子节点至少有一个安装监控。另外就是该节点安装了监控，那么其左右两棵子树只需要将自身的子孙部分覆盖即可，这种情况下不用管子节点自身是否安装了监控，因为子节点已经被当前节点所安装的监控所监视，这句话很重要，就是我不管他是否在子节点装了，反正当前节点的子节点的子孙部分一定要被覆盖。所以，我们需要的状态有三个，第一个就是覆盖以当前节点为根的树的最小摄像头数目，第二个就是当前节点有摄像头时需要的总摄像头数目，第三个是当前节点的子孙部分被覆盖所需的最小摄像头数目。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态量确定之后应该寻找转移方成，分别设这三个状态量为a,b,c。显然a应该从节点安装摄像头与否之间进行选择。对于b而言。 $$b = 1+L_c+R_c $$$$c = min(b,L_a+R_a) $$$$a = min(b,min(L_b+R_a,L_a+R_b)) $$这里L，R分别代表当前节点的儿子节点,首先b等于当前节点一个摄像头加上可以将自己两个子节点的子孙包括的摄像头数量。而c等于以当前节点安装监控的情况和两个子树的a值（将子树覆盖的最小数量），最终a就从当前节点安装摄像头和未安装摄像头的两种情况中两者取最小值。安装的值就是b，未安装的分为两种，一种就是左子树根节点安装摄像头，右子树取刚好覆盖的最小值，不一定要求在右子树根节点安装监控，另一种情况刚好相反。注意这里还要考率一种特殊情况，当子节点为空时，无法在上边安装摄像头，将该节点的初始b状态设为一个较大的值即可解决这个问题，因为我们取的是最小值，所以就可以自动消除影响。 代码12345678910111213141516171819class Solution {public: vector&lt;int&gt; dfs(TreeNode* root){ vector&lt;int&gt; temp{0,1000,0}; if(root==nullptr){ return temp; } auto l = dfs(root-&gt;left); auto r = dfs(root-&gt;right); temp[1] = 1 + l[2] + r[2]; temp[2] = min(temp[1],l[0]+r[0]); temp[0] = min(temp[1],min(l[1]+r[0],l[0]+r[1])); return temp; } int minCameraCover(TreeNode* root) { auto ans = dfs(root); return ans[0]; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树形dp实际上还是比较常规的，主要就是要稍微分析得仔细一点，将每个节点的状态列出来，然后找出父子节点之间的联系构造状态转移函式即可，时空复杂度就是常规的二叉树遍历的时空复杂度，但是这里因为返回值是vector需要拷贝，所以花费时间会比较久。","link":"/2020/09/22/leetcode-0922/"},{"title":"9月23日leetcode每日一题","text":"原题链接: 合并二叉树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本道题其实类似于链表合并，但是这个链表变成了二叉树，当然最开始写还有点不太适应这种写法，但是写法确实还是十分类似的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当遍历到某个节点，一个节点为空的时候就直接返回另一个节点。另外就改变其中一个子树节点的值，注意这里不要再次构造新的节点，会消耗多余的空间和时间，原地上进行改动就好了。 代码123456789101112class Solution {public: //堆内分配内存并不会随着栈的返回二失效 TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if(t1==nullptr)return t2; if(t2==nullptr)return t1; t1-&gt;val += t2-&gt;val; t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left); t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right); return t1; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时空复杂度取的两者覆盖新生成二叉树遍历所需的时空复杂度。","link":"/2020/09/23/leetcode-0923/"},{"title":"9月24日leetcode每日一题","text":"原题链接: 二叉树中的众数 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这种题目还蛮恶心的，因为虽然标注的难度是简单，但是往往还有进阶做法，像O（n）时间，O（1）空间这种。像今天这个就属于之前没学过就没法做的那种，题解采用的是Morris遍历以达到O（1）的时间复杂度。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Morris中序遍历有点像是将二叉树按照一个单链表展开，在进行中序遍历的时候会找到左子树的最右节点，将最右节点的右指针指向当前遍历节点，当然还会出现一种情况就是左子树的最右节点指向当前遍历节点说明成环了，所以这个时候我们应该将最右节点的右指针悬空来避免成环。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于从这样一个非递减的序列中寻找众数，每一串相同的数字都是连续的，所以我们只要判断最长连续数字的长度即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {private: int base,cnt = 0,maxcnt = 0; vector&lt;int&gt; ans;public: void update(int val){ // printf(&quot;%d\\n&quot;,val); if(val==base){ ++cnt; } else{ base = val; cnt = 1; } if(cnt==maxcnt)ans.push_back(val); else if(cnt &gt; maxcnt){ maxcnt = cnt; ans = {val}; } } vector&lt;int&gt; findMode(TreeNode* root) { while(root){ if(!root-&gt;left){ update(root-&gt;val); root = root-&gt;right; continue; } TreeNode* pre = root-&gt;left; while(pre-&gt;right&amp;&amp;pre-&gt;right!=root)pre = pre-&gt;right; if(pre-&gt;right==nullptr){ pre-&gt;right = root; root = root-&gt;left; } else{ //避免成环 pre-&gt;right = nullptr; update(root-&gt;val); root = root-&gt;right; } } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，时间复杂度还是O（n）,空间复杂度是O（1），感觉理解这个算法的关键在于自己动手去画一遍，不然将右节点右指针悬空那里确实不太好理解。","link":"/2020/09/24/leetcode-0924/"},{"title":"9月25日leetocde每日一题","text":"原题链接: 中序遍历和后序遍历还原二叉树 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题其实还挺常规的，大致的一个思路就是中序遍历根节点会二分左右子树，后序遍历的最后一个节点为根节点，然后利用分治的思想进行左右子树的递归即可。 题目很常规了，几乎没有难度，熟悉套路就好了。 代码123456789101112131415161718192021class Solution {vector&lt;int&gt; _in;vector&lt;int&gt; _post;public: TreeNode* build(int lm,int rm,int lp,int rp){ if(lm&gt;rm)return nullptr; TreeNode* ans = new TreeNode(_post[rp]); int i; for(i = lm;i&lt;=rm;++i){ if(_in[i]==ans-&gt;val)break; } ans-&gt;left = build(lm,i-1,lp,lp+i-1-lm); ans-&gt;right = build(i+1,rm,lp+i-lm,rp-1); return ans; } TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { _in = inorder; _post = postorder; return build(0,inorder.size()-1,0,postorder.size()-1); }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题的时间复杂度最坏情况下为O（N^2）,极端情况下为树只有左子树或者右子树。空间复杂度最会也为O(N)，一般情况下为O(H)，H是树的高度。","link":"/2020/09/25/leetcode-0925/"},{"title":"9月26日leetcode每日一题","text":"原题链接: 路径总和II 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题之前也写过了，思维量也不大，使用简单dfs就可以解决。大致方法就是从根节点开始递归，然后对于非空的子节点进行递归，递归边界条件为遍历当前节点左右子节点均为空。仔细想了一下好像其他也没有什么要注意的点，另外就是root可能为空，所以要考虑一下cornerc case。 代码12345678910111213141516171819202122232425262728class Solution {public: vector&lt;vector&lt;int&gt;&gt; ans;int target; void travel(TreeNode* root,vector&lt;int&gt;&amp; path,int total){ if(!root-&gt;left&amp;&amp;!root-&gt;right){ if(total == target)ans.push_back(path); return; } if(root-&gt;left){ path.push_back(root-&gt;left-&gt;val); travel(root-&gt;left,path,total+root-&gt;left-&gt;val); path.pop_back(); } if(root-&gt;right){ path.push_back(root-&gt;right-&gt;val); travel(root-&gt;right,path,total+root-&gt;right-&gt;val); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) { if(!root)return ans; target = sum; vector&lt;int&gt; temp; temp.push_back(root-&gt;val); travel(root,temp,root-&gt;val); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题的时间复杂度O（N），因为递归要走遍所有的节点，还不能够剪枝，因为题目也没有保证节点的值不可以为负数，所以每一个节点都要遍历到。空间复杂度为O（H），H为树的最大高度，即递归所产生的的最大栈空间。","link":"/2020/09/26/leetcode-0926/"},{"title":"9月7号leetcode每日一题","text":"原题链接:前k个高频元素 思考过程首先最直白的方法肯定是统计数字出现频率，然后排序选出频率最高的前K个数字。但是既然会用到排序，那么复杂度就会来到 O(nlogn),不太符合题目的要求。这时候很自然的就想到了快速的partition来进行划分，划分出来频率高的一边有k个即可。另外一种想法就是(纯靠自己乱想的)，因为题目保证答案唯一，所以频率最高的前K个数字是确定的，使用map计数，然后每轮对元素数目每次减去1，这样某一轮过后，必定会在map中只剩K个元素，最后push到结果即可。 自行思考的方法1234567891011121314151617181920vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int,int&gt; mp; for(auto&amp; item:nums){ ++mp[item]; } int cnt = mp.size(); while(cnt&gt;k){ for(auto&amp; item:mp){ item.second--; if(item.second==0){ --cnt; } } } vector&lt;int&gt; ans; for(auto&amp; item:mp){ if(item.second&gt;0)ans.push_back(item.first); } return ans; quick sort12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) { int picked = rand() % (end - start + 1) + start; swap(v[picked], v[start]); int pivot = v[start].second; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (v[i].second &gt;= pivot) { swap(v[index + 1], v[i]); index++; } } swap(v[start], v[index]); if (k &lt;= index - start) { qsort(v, start, index - 1, ret, k); } else { for (int i = start; i &lt;= index; i++) { ret.push_back(v[i].first); } if (k &gt; index - start + 1) { qsort(v, index + 1, end, ret, k - (index - start + 1)); } } } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v: nums) { occurrences[v]++; } vector&lt;pair&lt;int, int&gt;&gt; values; for (auto&amp; kv: occurrences) { values.push_back(kv); } vector&lt;int&gt; ret; qsort(values, 0, values.size() - 1, ret, k); return ret; }}; minimum heap1234567891011121314151617181920212223242526272829303132333435class Solution {public: /* 提醒一下，这里定义成员函数的话要尾置const,定义priority的cmp函数都要注意这一点。 */ static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) { return m.second &gt; n.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp); for (auto&amp; [num, count] : occurrences) { if (q.size() == k) { if (q.top().second &lt; count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector&lt;int&gt; ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; }}; 总结总的来说，快排的思路最好想，平均时间复杂度也只有O(n)，虽然最坏是O（n^2），小根堆则是利用了数据结构的特点，但是其时间复杂度并不太好O（nlogk），我自己想的方法就参考一下吧（其实有点像快乐模拟23333）。","link":"/2020/09/07/leetcode-daily-0907/"},{"title":"9月13号leetcode每日一题","text":"思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题一开始肯定想的是使用dfs，外加bool型数组记录是否被选取，但是发现我自己原来写的并没有剪枝，但是时间效率还不错…看了题解，发现也是简单dfs加回溯。。。无语，那就这样写吧，这样的话感觉这道题就没有什么意义了，纯粹考察熟练度。 代码1234567891011121314151617181920212223242526272829303132class Solution {public: bool ans = false; int direct[4][2]={ {1,0},{0,1},{-1,0},{0,-1} }; bool book[200][200]={false}; void dfs(const string&amp; word,const vector&lt;vector&lt;char&gt;&gt;&amp; target,int index,int x,int y){ if(ans)return;//部分剪枝 if(index+1==word.size()){ans=true;return;} for(int i=0;i&lt;4;i++){ int tx= x+direct[i][0],ty = y+direct[i][1]; if(tx&lt;0||tx&gt;=target.size()||ty&lt;0||ty&gt;=target[0].size())continue; if(!book[tx][ty]&amp;&amp;target[tx][ty]==word[index+1]){ book[tx][ty]=true; dfs(word,target,index+1,tx,ty); book[tx][ty]=false; } } } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { for(int i=0;i&lt;board.size();i++){ for(int j=0;j&lt;board[0].size();++j){ if(board[i][j]==word[0]){ book[i][j]=true;dfs(word,board,0,i,j);book[i][j]=false; } } } return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里感觉时间复杂度是O（MNL）,和官方题解不一样这里没有计算条件分支，感觉这里的条件分支可一并到一起，加不加那个指数感觉无关紧要。空间复杂度很明显，栈的深度最大是L，bool型数组大小为M*N。","link":"/2020/09/13/leetcode-o913/"},{"title":"9月15号leetcode每日一题","text":"原题链接 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话，这道题还是有一定的思考量的，刚开始想的是建立每行每列以及每个cell，之后就是把空的点push到一个队列里面，如果当前点可以进行填写（意思就是说其他8个数已经确定），就将节点pop出去，如果不能进行填写，pop出去之后就再push进入队尾。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这样其实有一个问题就是有的数独他可能不会出现上述情况，比如说有的数读就是要你猜测某个点的值，你具有试错机会，所以说上面那种算法不仅耗时比较长，而且有可能会进入死循环。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们在这里采用的是题解中的方法，采用的是dfs式的递归方法，如果遇到冲突，还可以进行回溯试错。并且更进一步的还有bitset方法，占用空间较小（虽然最后出来的结果好像不是特别好2333） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution {private: vector&lt;bitset&lt;9&gt;&gt; rows; vector&lt;bitset&lt;9&gt;&gt; cols; vector&lt;vector&lt;bitset&lt;9&gt;&gt;&gt; cells;public: bitset&lt;9&gt; status(int x,int y){ return ~(rows[x]|cols[y]|cells[x/3][y/3]); } //返回有效位置bitset应该是没有问题的。 pair&lt;int,int&gt; getNext(vector&lt;vector&lt;char&gt;&gt;&amp; board){ pair&lt;int,int&gt; ret; int min_cnt = 10;//代表10中可能选择的方案，我们这里选择的是最小选择数目的那个点 for(int i = 0;i&lt;9;++i){ for(int j = 0;j&lt;9;++j){ if(board[i][j]=='.'){ auto temp = status(i,j); if(temp.count()&lt;min_cnt){ ret = {i,j}; min_cnt = temp.count(); } } } } return ret; } //每次返回下一个最少选择的位置没有问题 void fillNum(int x,int y,int n,bool flag){ rows[x][n] = flag ? 1 : 0; cols[y][n] = flag ? 1 : 0; cells[x/3][y/3][n] = flag ? 1 : 0; } bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int cnt){ // printf(&quot;%d\\n&quot;,cnt); if(cnt == 0)return true; auto next = getNext(board); auto bits = status(next.first,next.second); for(int i = 0;i&lt;9;++i){ if(bits.test(i)){ //说明这个点可以选，选择这个点之后更新各个数组的状态，然后进行下一轮的递归 fillNum(next.first,next.second,i,true); board[next.first][next.second] = i + '1'; if(dfs(board,cnt-1))return true; board[next.first][next.second] = '.'; fillNum(next.first,next.second,i,false); } } return false; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { rows.resize(9); cols.resize(9); cells.resize(3,vector&lt;bitset&lt;9&gt;&gt;(3)); int cnt = 0; for(int i = 0;i&lt;9;++i){ for(int j = 0;j&lt;9;++j){ if(board[i][j] == '.'){++cnt;continue;} int n = board[i][j] - '1'; rows[i] |= (1&lt;&lt;n); cols[j] |= (1&lt;&lt;n); cells[i/3][j/3] |= (1&lt;&lt;n); } } // printf(&quot;Initialization is okay.\\n&quot;); dfs(board,cnt); }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里比较精妙的就是设置了一个找出了一个可选数字最少的空白点，这样出错几率相对来说会更小。getNext函数，对全表进行扫描来选出目标点，而找到目标的方法就是对空点进行剩余可选个数计算，这就是status函数的作用。然后每次我们遍历一个点选择一个数的时候，应该要对相应的行，列以及块进行更新。这就是fillNum的功能，dfs形式选择参数为剩余的空白点。这里有一个小技巧，如果有一个路径走通了，其他路径就不用走了，所以返回类型可以设置为bool，返回为true的时候就也直接return true,以达到剪枝的目的。时间复杂度和空间复杂度，因为这里数独的维度是固定死的，所以都是常数级别。","link":"/2020/09/15/leetocde-0915/"},{"title":"记录一次线上环境配置以及测试","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近几天再忙学校自动填表的线上项目部署，遇到了不少问题，为防止以后忘记，在此特地记录一下。 mysql插入操作报错报错信息为 1$:incorrect value .......... for column 1 &nbsp;&nbsp;&nbsp;&nbsp;中间省略号为一串乱码，一般这种问题就和编码相关，去查了一下，mysql默认编码为latin1,插入中文数据会报错，需要对表和数据库的编码进行修改。&nbsp;&nbsp;&nbsp;&nbsp;去stackoverflow上面查询对应的解决方案 12345678910111213141516171819#For databaseALTER DATABASE databasename CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;#For tableALTER TABLE tablename CONVERT TO CHARACTER SET utfmb4 COLLATE utf8mb4_unicode_ci;#For columnALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; &nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，mysql的unicode编码为3个字节，所以得将字符编码设置为utf8mb4(话说我本地的mysql好像版本新一些8.0，不用改编码也能跑,centos7给👴爬)。 &nbsp;&nbsp;&nbsp;&nbsp;这里出现了一个COLLATE字段，可以简单理解为字段组织排序的方式，ci尾缀代表case insensitive。更详细的可以参考掘金的这篇博客 &nbsp;&nbsp;&nbsp;&nbsp;修改字符集之后插入成功 ssh远程连接+debug过程&nbsp;&nbsp;&nbsp;&nbsp;按理来说这个其实比较简单，就是按照 1$:ssh username@ip_address 初次输入密码，在本地生成公钥私钥文件 1ssh-keygen -t rsa -b 4096 更多参数可以查手册，默认是2048位的。之后通过scp命令传输文件将公钥传输到.ssh文件夹下面，并且传输内容到authorized_keys中。 1scp local/path/.ssh/id_rsa.pub username@ip_address: remote/path/.ssh/uploaded_file_name On remote side 123cat ~/.ssh/uploaded_file &gt;&gt; ~/.ssh/authorized_keyschmod 700 ~/.ssh/chmod 600 ~/.ssh/* chmod stands for change mod, which means changes to different access level.&nbsp;&nbsp;&nbsp;&nbsp;突然写起英文2333，这上面的步骤都很简单，但是在我原来的PC上都不管用，最后的原因是因为我的$HOME变量中含有中文。所以问题的解决方案就是修改中文用户名为英文，具体过程就不再啰嗦了。&nbsp;&nbsp;&nbsp;&nbsp;大致就是注销当前账号，使用administrator登录，修改用户文件夹和注册表中的路径名字，在切换回来。就可以不用使用密码远程连接主机了。 额外啰嗦为了使主机更加安全，可以禁用密码验证，修改/etc/ssh/sshd_config文件，将password authentication修改为false,记得修改之前备份文件. 123sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak#centos7使用这中格式的指令systemctl restart sshd 本来还想把cron定时运行脚本以及grep查找指令也写一下，时间太晚了就先写这么多了。","link":"/2020/09/08/online-test/"}],"tags":[{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"leftmost prefix index","slug":"leftmost-prefix-index","link":"/tags/leftmost-prefix-index/"},{"name":"depth-first-search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"combination","slug":"combination","link":"/tags/combination/"},{"name":"depth first search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"cut branch","slug":"cut-branch","link":"/tags/cut-branch/"},{"name":"breadth-first-search","slug":"breadth-first-search","link":"/tags/breadth-first-search/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"inorder traverse","slug":"inorder-traverse","link":"/tags/inorder-traverse/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"grapth","slug":"grapth","link":"/tags/grapth/"},{"name":"disjoint-set","slug":"disjoint-set","link":"/tags/disjoint-set/"},{"name":"permutation","slug":"permutation","link":"/tags/permutation/"},{"name":"binary-tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"dynamic programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"traverse","slug":"traverse","link":"/tags/traverse/"},{"name":"Treelike-dp","slug":"Treelike-dp","link":"/tags/Treelike-dp/"},{"name":"morris traversal","slug":"morris-traversal","link":"/tags/morris-traversal/"},{"name":"min heap","slug":"min-heap","link":"/tags/min-heap/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"},{"name":"bit operation","slug":"bit-operation","link":"/tags/bit-operation/"},{"name":"hashtable","slug":"hashtable","link":"/tags/hashtable/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"data structure","slug":"data-structure","link":"/categories/data-structure/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"leetcode-daily","slug":"leetcode-daily","link":"/categories/leetcode-daily/"},{"name":"leetocde-daily","slug":"leetocde-daily","link":"/categories/leetocde-daily/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}]}