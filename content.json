{"pages":[],"posts":[{"title":"My_First_Post","text":"第一次部署总算是把页面部署好了(django写的因为自己不会前端+审美强迫症暂时留坑)，虽然还有很多不完善的地方，但是暂时来说基本上能用就行了，后期可能会添加评论，分享以及广告之类的功能&amp;&amp;备案&amp;&amp;申请新的域名之类的功能。 碎碎念 作为一名cs学生，以后博客应该还是偏向技术性的，目前已经想好的是将leetcode每日一题题解和代码发布在博客。一些读书笔记，比如CCIA，可能会学习的golang，unix programming interface之类的（书买太多了2333） 联系PO一下联系方式吧，万一哪天我就有读者了呢hhhh 邮箱：woshizhansen@gmail.com qq: 1369905261 1printf(&quot;Keep coding and move forward!\\n&quot;);","link":"/2020/09/06/My-First-Post/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/06/hello-world/"},{"title":"9月8号leetcode每日一题","text":"原题链接 组合 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题刚拿到一看就比较典型，组合选k个数字，应该可以用dfs解决。但是这道题要求的是组合，如果按照循环遍历选一个再用bool数组记录选取情况的话，会产生很多不必要的递归路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此要确定每个组合只有一个排列会push到最终结果，方法就是规定一个顺序即可，这里就规定递增顺序即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是做出来之后效率比较低下，应该是没有进行剪枝，仔细一想，每次要求遍历开始的部分直接从已有数字+1开始（数组为空时取1即可），修改之后最大时间缩短为十分之一。然而超过人数占比并不理想，所以在想了想，要是当前剩余可遍历元素少于所需元素个数，好像也可以直接返回，最后运行结果16ms,超过94%。 dfs递归代码12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void dfs(int left,int n,vector&lt;int&gt;&amp; target){ if(left==0){ ans.push_back(target); return; } int i = target.empty()? 1 :target.back()+1; int bound = n - left + 1; for(;i&lt;=bound;++i){ target.push_back(i); dfs(left-1,n,target); target.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { //注意不是排列是组合，所以要想个办法使得每个组合的排列只出现一次， //好像规定组合内数字递增即可，递增算是同一组合的唯一排序 vector&lt;int&gt; temp; dfs(k,n,temp); return ans; }}; 非递归二进制组合代码思路这里是官方题解中给出的思路，意思就是选取k个数字，转换为一个n位2进制数应该是k个1，n-k个0，我们要找到一种从最低k位全1到最高k位全1的变换方法，这种方法很好理解，就是先最高位加1，然后整体从高到低都加1。一轮过后最高位加1，再开始。**注意代码实现使用了一点小trick，即在尾部多添加一个n+1的数字，其实在1到n之外的数字都行，仔细品味2333**。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { // 初始化 // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k] // 末尾加一位 n + 1 作为哨兵 for (int i = 1; i &lt;= k; ++i) { temp.push_back(i); } temp.push_back(n + 1); int j = 0; while (j &lt; k) { ans.emplace_back(temp.begin(), temp.begin() + k); j = 0; // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t] while (j &lt; k &amp;&amp; temp[j] + 1 == temp[j + 1]) { temp[j] = j + 1; ++j; } // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置 ++temp[j]; } return ans; }}; 总结题目算是在普通dfs上的一个变式，时间效率上的pogai也再次提醒我们剪枝的重要性，另外利用二进制数进行模拟这种方法还是比较难想到的，算是拓宽视野了。 碎碎念今天终于收到字节面试通知了，有点高兴又有点紧张，努力准备，加油！","link":"/2020/09/08/leetcode-0908/"},{"title":"9月7号leetcode每日一题","text":"原题链接:前k个高频元素 思考过程首先最直白的方法肯定是统计数字出现频率，然后排序选出频率最高的前K个数字。但是既然会用到排序，那么复杂度就会来到 O(nlogn),不太符合题目的要求。这时候很自然的就想到了快速的partition来进行划分，划分出来频率高的一边有k个即可。另外一种想法就是(纯靠自己乱想的)，因为题目保证答案唯一，所以频率最高的前K个数字是确定的，使用map计数，然后每轮对元素数目每次减去1，这样某一轮过后，必定会在map中只剩K个元素，最后push到结果即可。 自行思考的方法1234567891011121314151617181920vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int,int&gt; mp; for(auto&amp; item:nums){ ++mp[item]; } int cnt = mp.size(); while(cnt&gt;k){ for(auto&amp; item:mp){ item.second--; if(item.second==0){ --cnt; } } } vector&lt;int&gt; ans; for(auto&amp; item:mp){ if(item.second&gt;0)ans.push_back(item.first); } return ans; quick sort12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) { int picked = rand() % (end - start + 1) + start; swap(v[picked], v[start]); int pivot = v[start].second; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (v[i].second &gt;= pivot) { swap(v[index + 1], v[i]); index++; } } swap(v[start], v[index]); if (k &lt;= index - start) { qsort(v, start, index - 1, ret, k); } else { for (int i = start; i &lt;= index; i++) { ret.push_back(v[i].first); } if (k &gt; index - start + 1) { qsort(v, index + 1, end, ret, k - (index - start + 1)); } } } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v: nums) { occurrences[v]++; } vector&lt;pair&lt;int, int&gt;&gt; values; for (auto&amp; kv: occurrences) { values.push_back(kv); } vector&lt;int&gt; ret; qsort(values, 0, values.size() - 1, ret, k); return ret; }}; minimum heap1234567891011121314151617181920212223242526272829303132333435class Solution {public: /* 提醒一下，这里定义成员函数的话要尾置const,定义priority的cmp函数都要注意这一点。 */ static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) { return m.second &gt; n.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp); for (auto&amp; [num, count] : occurrences) { if (q.size() == k) { if (q.top().second &lt; count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector&lt;int&gt; ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; }}; 总结总的来说，快排的思路最好想，平均时间复杂度也只有O(n)，虽然最坏是O（n^2），小根堆则是利用了数据结构的特点，但是其时间复杂度并不太好O（nlogk），我自己想的方法就参考一下吧（其实有点像快乐模拟23333）。","link":"/2020/09/07/leetcode-daily-0907/"}],"tags":[{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"depth-first-search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"combination","slug":"combination","link":"/tags/combination/"},{"name":"min heap","slug":"min-heap","link":"/tags/min-heap/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"leetcode-daily","slug":"leetcode-daily","link":"/categories/leetcode-daily/"}]}