{"pages":[],"posts":[{"title":"My_First_Post","text":"第一次部署总算是把页面部署好了(django写的因为自己不会前端+审美强迫症暂时留坑)，虽然还有很多不完善的地方，但是暂时来说基本上能用就行了，后期可能会添加评论，分享以及广告之类的功能&amp;&amp;备案&amp;&amp;申请新的域名之类的功能。 碎碎念 作为一名cs学生，以后博客应该还是偏向技术性的，目前已经想好的是将leetcode每日一题题解和代码发布在博客。一些读书笔记，比如CCIA，可能会学习的golang，unix programming interface之类的（书买太多了2333） 联系PO一下联系方式吧，万一哪天我就有读者了呢hhhh 邮箱：woshizhansen@gmail.com qq: 1369905261 1printf(&quot;Keep coding and move forward!\\n&quot;);","link":"/2020/09/06/My-First-Post/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/06/hello-world/"},{"title":"9月8号leetcode每日一题","text":"原题链接 组合 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题刚拿到一看就比较典型，组合选k个数字，应该可以用dfs解决。但是这道题要求的是组合，如果按照循环遍历选一个再用bool数组记录选取情况的话，会产生很多不必要的递归路径。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此要确定每个组合只有一个排列会push到最终结果，方法就是规定一个顺序即可，这里就规定递增顺序即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是做出来之后效率比较低下，应该是没有进行剪枝，仔细一想，每次要求遍历开始的部分直接从已有数字+1开始（数组为空时取1即可），修改之后最大时间缩短为十分之一。然而超过人数占比并不理想，所以在想了想，要是当前剩余可遍历元素少于所需元素个数，好像也可以直接返回，最后运行结果16ms,超过94%。 dfs递归代码12345678910111213141516171819202122232425class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void dfs(int left,int n,vector&lt;int&gt;&amp; target){ if(left==0){ ans.push_back(target); return; } int i = target.empty()? 1 :target.back()+1; int bound = n - left + 1; for(;i&lt;=bound;++i){ target.push_back(i); dfs(left-1,n,target); target.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { //注意不是排列是组合，所以要想个办法使得每个组合的排列只出现一次， //好像规定组合内数字递增即可，递增算是同一组合的唯一排序 vector&lt;int&gt; temp; dfs(k,n,temp); return ans; }}; 非递归二进制组合代码思路这里是官方题解中给出的思路，意思就是选取k个数字，转换为一个n位2进制数应该是k个1，n-k个0，我们要找到一种从最低k位全1到最高k位全1的变换方法，这种方法很好理解，就是先最高位加1，然后整体从高到低都加1。一轮过后最高位加1，再开始。**注意代码实现使用了一点小trick，即在尾部多添加一个n+1的数字，其实在1到n之外的数字都行，仔细品味2333**。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { // 初始化 // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k] // 末尾加一位 n + 1 作为哨兵 for (int i = 1; i &lt;= k; ++i) { temp.push_back(i); } temp.push_back(n + 1); int j = 0; while (j &lt; k) { ans.emplace_back(temp.begin(), temp.begin() + k); j = 0; // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t] while (j &lt; k &amp;&amp; temp[j] + 1 == temp[j + 1]) { temp[j] = j + 1; ++j; } // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置 ++temp[j]; } return ans; }}; 总结题目算是在普通dfs上的一个变式，时间效率上的pogai也再次提醒我们剪枝的重要性，另外利用二进制数进行模拟这种方法还是比较难想到的，算是拓宽视野了。 碎碎念今天终于收到字节面试通知了，有点开心又有点紧张，总之努力准备，加油！","link":"/2020/09/08/leetcode-0908/"},{"title":"9月9日leetcode每日一题","text":"原题链接: 组合总和 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说句题外话，这道题和昨天的那道组合数基本一样，只不过要自己额外做点处理，甚至在剪枝的要求上还不如昨天那道题。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拿到这道题的第一想法就是我先用大的数去减这个target，减不动了再用小一点的数字。这一点很好理解，相当于将所有可行解按照解的长度由小到大排列。但是这里没有保证数组有序，所以预先排序即可。但是第一次实现的时候，发现有重复组合，消除重复组合的方法昨天的博客里面已经提到，限定一种顺序即可，这里我们按照从大到小的顺序，因为可以重复选取元素，所记得选元素的时候可以是小于等于。 代码123456789101112131415161718192021222324class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; curr){ if(left==0){ ans.push_back(curr); return; } for(int i = candi.size()-1;i&gt;=0;--i){ if(left&gt;=candi[i]&amp;&amp;(curr.empty()||curr.back()&gt;=candi[i])){ curr.push_back(candi[i]); traverse(left-candi[i],candi,curr); curr.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp); return ans; }}; 总结这里要注意一点要先判定curr是否为空再判断curr.back()与candi[i]的大小关系，不然会出现访问不存在元素的未定义行为，所以书本里面写的很有道理，先检查边界有效性，再检查内容。另外提一句，这里时间效率已经超过90%，进一步剪枝的话就把curr.empty()和curr.back()&gt;=candi[i]这个判定拉出来，直接让i从符合条件的位置开始遍历，或者再在traverse中添加一个index参数，记录上次选取的index，这次选取就从index（想想为什么不是index-1?）开始递减遍历。","link":"/2020/09/09/leetcode-0909/"},{"title":"9月10号leetcode每日一题","text":"原题链接: 组合总和|| 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天还是组合类型题目，无语…唯一的区别就是每个数字之可以选取一次，并且可选数字中会出现重复的数字，所以这道题最大的难点在于去重。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要去重就要分析可能出现重复的情况，举个例子来自说，target是11，candidates是[1,10,10]，这样就会出现重复的解，为了避免这样的情况，需要做的就是在每一轮递归的过程中不要选取重复的值（这里的意思并不是说排查了一个数字选多次的情况，因为同一个数字可以再下一轮递归中进行选取），如果同一轮递归选取了两个相同的值，刚好后面的几轮递归的数字是一样的话，就会产生重复的解。另外的话，为了避免选取重样的值，可以传入index作为下轮开始选取的起点，避免重读的同时还做到了剪枝。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外再提到一点就是这里如果顺序是按照从小到大遍历，如果left已经小于当前可选值，可以直接return，这也算一种剪枝。 代码12345678910111213141516171819202122232425262728class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,vector&lt;int&gt;&amp; candi,vector&lt;int&gt;&amp; container,int index){ if(left==0){ ans.push_back(container); return; } //这里是防止每轮选取中避免选到相同的数字，除了，大于等于0之外， int pre = 0; for(int i = index;i&lt;candi.size();++i){ if(left&gt;=candi[i]&amp;&amp;candi[i]!=pre){ pre = candi[i]; container.push_back(candi[i]); traverse(left-candi[i],candi,container,i+1); container.pop_back(); } else if(left&lt;candi[i])return; } } vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; traverse(target,candidates,temp,0); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想分析一下这里的复杂度，考虑最坏情况，没有相等的数字，并且没有一种情况可以达成有效解（target很大），每条路径走到底应该要2^n倍时间复杂，从最初的遍历算一共有n个数可供选择，当然到最后由于index传入的剪枝，时间会小于2^n，总的上限应该是O(n*2^n),系数应该小于1，这个时间复杂度大于O(nlogn)。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空间复杂度就是O(n),取的是递归最大深度。","link":"/2020/09/10/leetcode-0910/"},{"title":"9月11号leetcode每日一题","text":"原题链接: 组合总和 III 思考过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leetocde这几天感觉是要弄一个组合周…，总的来说还是换汤不换药，问题的关键在于去除重复的组合，重点是题目中说明不会出现重复的数字，这样就很简单了，递归函数包括两个参数，一个是剩余选取次数，一个是剩余选取大小，只有两者都为0时才能将结果push进最终答案，感觉实在没有什么好说的，确实太水了。。。 代码1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; ans;public: void traverse(int left,int num_left,int last,vector&lt;int&gt;&amp; target){ if(left==0||num_left==0){ if(!left&amp;&amp;!num_left)ans.push_back(target); return; } for(int i = last+1;i&lt;=9;++i){ if(num_left&gt;=i){ target.push_back(i); traverse(left-1,num_left-i,i,target); target.pop_back(); } } } vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { vector&lt;int&gt; temp; traverse(k,n,0,temp); return ans; }}; 总结&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里最后的时间效率超过了99%，主要是从大到小遍历进行了剪枝，按照选取次数进行时间复杂度分析，一共有C(9,k)条路径选择，每条最大深度为k，时间复杂度为O(C(9,k)*k),当然因为这里进行了剪枝，实际上会更小。空间复杂度，临时数组大小为k,栈的最大深度为k，所以空间复杂度为O(k)（终于赶在上飞机前写完了2333）。","link":"/2020/09/11/leetcode-0911/"},{"title":"9月7号leetcode每日一题","text":"原题链接:前k个高频元素 思考过程首先最直白的方法肯定是统计数字出现频率，然后排序选出频率最高的前K个数字。但是既然会用到排序，那么复杂度就会来到 O(nlogn),不太符合题目的要求。这时候很自然的就想到了快速的partition来进行划分，划分出来频率高的一边有k个即可。另外一种想法就是(纯靠自己乱想的)，因为题目保证答案唯一，所以频率最高的前K个数字是确定的，使用map计数，然后每轮对元素数目每次减去1，这样某一轮过后，必定会在map中只剩K个元素，最后push到结果即可。 自行思考的方法1234567891011121314151617181920vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); unordered_map&lt;int,int&gt; mp; for(auto&amp; item:nums){ ++mp[item]; } int cnt = mp.size(); while(cnt&gt;k){ for(auto&amp; item:mp){ item.second--; if(item.second==0){ --cnt; } } } vector&lt;int&gt; ans; for(auto&amp; item:mp){ if(item.second&gt;0)ans.push_back(item.first); } return ans; quick sort12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: void qsort(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end, vector&lt;int&gt;&amp; ret, int k) { int picked = rand() % (end - start + 1) + start; swap(v[picked], v[start]); int pivot = v[start].second; int index = start; for (int i = start + 1; i &lt;= end; i++) { if (v[i].second &gt;= pivot) { swap(v[index + 1], v[i]); index++; } } swap(v[start], v[index]); if (k &lt;= index - start) { qsort(v, start, index - 1, ret, k); } else { for (int i = start; i &lt;= index; i++) { ret.push_back(v[i].first); } if (k &gt; index - start + 1) { qsort(v, index + 1, end, ret, k - (index - start + 1)); } } } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v: nums) { occurrences[v]++; } vector&lt;pair&lt;int, int&gt;&gt; values; for (auto&amp; kv: occurrences) { values.push_back(kv); } vector&lt;int&gt; ret; qsort(values, 0, values.size() - 1, ret, k); return ret; }}; minimum heap1234567891011121314151617181920212223242526272829303132333435class Solution {public: /* 提醒一下，这里定义成员函数的话要尾置const,定义priority的cmp函数都要注意这一点。 */ static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) { return m.second &gt; n.second; } vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; occurrences; for (auto&amp; v : nums) { occurrences[v]++; } // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp); for (auto&amp; [num, count] : occurrences) { if (q.size() == k) { if (q.top().second &lt; count) { q.pop(); q.emplace(num, count); } } else { q.emplace(num, count); } } vector&lt;int&gt; ret; while (!q.empty()) { ret.emplace_back(q.top().first); q.pop(); } return ret; }}; 总结总的来说，快排的思路最好想，平均时间复杂度也只有O(n)，虽然最坏是O（n^2），小根堆则是利用了数据结构的特点，但是其时间复杂度并不太好O（nlogk），我自己想的方法就参考一下吧（其实有点像快乐模拟23333）。","link":"/2020/09/07/leetcode-daily-0907/"},{"title":"记录一次线上环境配置以及测试","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近几天再忙学校自动填表的线上项目部署，遇到了不少问题，为防止以后忘记，在此特地记录一下。 mysql插入操作报错报错信息为 1$:incorrect value .......... for column 1 &nbsp;&nbsp;&nbsp;&nbsp;中间省略号为一串乱码，一般这种问题就和编码相关，去查了一下，mysql默认编码为latin1,插入中文数据会报错，需要对表和数据库的编码进行修改。&nbsp;&nbsp;&nbsp;&nbsp;去stackoverflow上面查询对应的解决方案 12345678910111213141516171819#For databaseALTER DATABASE databasename CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;#For tableALTER TABLE tablename CONVERT TO CHARACTER SET utfmb4 COLLATE utf8mb4_unicode_ci;#For columnALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; &nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，mysql的unicode编码为3个字节，所以得将字符编码设置为utf8mb4(话说我本地的mysql好像版本新一些8.0，不用改编码也能跑,centos7给👴爬)。 &nbsp;&nbsp;&nbsp;&nbsp;这里出现了一个COLLATE字段，可以简单理解为字段组织排序的方式，ci尾缀代表case insensitive。更详细的可以参考掘金的这篇博客 &nbsp;&nbsp;&nbsp;&nbsp;修改字符集之后插入成功 ssh远程连接+debug过程&nbsp;&nbsp;&nbsp;&nbsp;按理来说这个其实比较简单，就是按照 1$:ssh username@ip_address 初次输入密码，在本地生成公钥私钥文件 1ssh-keygen -t rsa -b 4096 更多参数可以查手册，默认是2048位的。之后通过scp命令传输文件将公钥传输到.ssh文件夹下面，并且传输内容到authorized_keys中。 1scp local/path/.ssh/id_rsa.pub username@ip_address: remote/path/.ssh/uploaded_file_name On remote side 123cat ~/.ssh/uploaded_file &gt;&gt; ~/.ssh/authorized_keyschmod 700 ~/.ssh/chmod 600 ~/.ssh/* chmod stands for change mod, which means changes to different access level.&nbsp;&nbsp;&nbsp;&nbsp;突然写起英文2333，这上面的步骤都很简单，但是在我原来的PC上都不管用，最后的原因是因为我的$HOME变量中含有中文。所以问题的解决方案就是修改中文用户名为英文，具体过程就不再啰嗦了。&nbsp;&nbsp;&nbsp;&nbsp;大致就是注销当前账号，使用administrator登录，修改用户文件夹和注册表中的路径名字，在切换回来。就可以不用使用密码远程连接主机了。 额外啰嗦为了使主机更加安全，可以禁用密码验证，修改/etc/ssh/sshd_config文件，将password authentication修改为false,记得修改之前备份文件. 123sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak#centos7使用这中格式的指令systemctl restart sshd 本来还想把cron定时运行脚本以及grep查找指令也写一下，时间太晚了就先写这么多了。","link":"/2020/09/08/online-test/"}],"tags":[{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"depth-first-search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"combination","slug":"combination","link":"/tags/combination/"},{"name":"depth first search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"cut branch","slug":"cut-branch","link":"/tags/cut-branch/"},{"name":"min heap","slug":"min-heap","link":"/tags/min-heap/"},{"name":"quick sort","slug":"quick-sort","link":"/tags/quick-sort/"},{"name":"hashmap","slug":"hashmap","link":"/tags/hashmap/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"}],"categories":[{"name":"随记","slug":"随记","link":"/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"leetcode-daily","slug":"leetcode-daily","link":"/categories/leetcode-daily/"},{"name":"linux","slug":"linux","link":"/categories/linux/"}]}