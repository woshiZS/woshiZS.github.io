---
title: 后台开发1-3章读书笔记
toc: true
mathjax: true
date: 2020-09-28 21:08:25
password:
summary:
tags:
    - C++
categories:
    - 读书笔记
---
### 前言
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来想着再开一个仓库的，但是感觉乱七八糟的仓库开太多了也不是特别好，就直接加到博客里面了。
### chapter 1 c++ 基础
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再次吐槽一下，没有vim8是真的难用，权当锻炼自己手速了。
> * 使用unio来进行判断自己机器是big endian还是small endian，一般来说网络传输之中都采用的是big endian。
> * 另外一个就是内存对齐，觉得书里面讲得不够详细，可以去看[知乎这篇帖子](https://zhuanlan.zhihu.com/p/30007037),主要提到了一个#pragma pack(n)的问题，文中好像出现了一个错误就是pack应该是取最大成员和默认pack的较大值，主要还是为了取址方便，进行计算的时候相当于先按照对齐单位去取，要是一个对其单位大小的空间不够的话，就会增加一个对齐单位大小的空间。\
<!--more-->
> 有一个很有意思的例子是使用union和struct相结合。
```c++
#include<iostream>
using namespace std;
typedef union{
    long i;
    int k[5];
    char c;
}UDATE;
struct data{
    int cat;
    UDATE cow;
    double dog;
}too;
UDATE temp;
int main(){
    cout<<sizeof(too)<<endl;
    cout<<sizeof(temp)<<endl;
    return 0;
}
```
答案是40和24，自己可以稍微想一想。
#### 预处理
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要就是四个功能，宏定义，文件包含，条件编译和布局控制。
* 宏定义；本质上属于替换，主要有两种形式，一种是直接替换，像```#define PI 3.1415926```这种,另外就是就是类似于函数那种，如```#define area(x) ((x)*(x))```，写宏定义的时候需要注意的点就是要多加括号，该加括号的地方一个也不能少，否则在替换的时候会产生意想不到的结果。
* 这里重点讲一个do while(0)的妙用。
```c++
#define Foo(x){
    //statement one
    //statement two
}

if (condition)
    Foo(x);
else
    ...
```
如果这样写的话就会else就会和前面的语句孤立起来，单独的else是不可以直接存在的，所以会产生错误，这时候采用另外一种写法。
```c++
#define Foo(x) do{\
    //statement one
    //statement two
}while(0)
```
并且要注意的是这里是没有括号的。
* 条件编译
```c++
#ifdef <something>
    //progma
#else
    //another progma
#endif
```
比如下面这种:
```c++
#include<iostream>
#include<cstdio>
using namespace std;
//#define _DEBUG_ 1
int main(){
    int x = 10;
    #ifdef _DEBUG_
        cout<<"File:"<<__FILE__<<",Line:"<<__LINE__<<",x:"<<x<<endl;
    #else
        printf("x = %d\n",x);
        cout<<x<<endl;
    #endif
    return 0;
}
```
这要前面有这个_DEBUG_的宏定义，不管定义成啥，甚至后面都没有东西都行，就会执行第一段代码。
* extern C\
主要原因是因为函数重载所引起的，c++里面重载函数在进行汇编的时候会对函数名字进行一些额外处理，而在C语言中只是简单的函数名字而已，加入```extern C```的目的是为了告诉编译器这段代码按照C的标准进行编译。另外一个要注意的点就是C++程序的预定义宏__cplusplus。

### Chapter 2 面对对象
* 编码规范，将private成员放到类的最后，就能使读者的精力集中在被外界调用的公有成员上面。
* 访问权限就不用多说，public,private,protected,这个都是老生常谈了，除了定义访问权限之外，还要注意接口和实现的分离，一个比较经典的就是头文件进行声明，源文件进行实现。**注意如果多添加了其他的源文件，在最后编译的时候要链接那个文件**
* 默认构造函数参数所带来的的歧义，有的时候如果所有的构造函数都有参数，再定义默认（无参）构造函数，或者参数个数小于该构造函数的构造函数，调用的时候会引起歧义。
* 析构函数，一般来说栈中分配内存的对象，在作用域结束的位置就会自动调用析构函数，但是new分配，就是动态内存分配的对象，只有在调用delete之后才会调用析构函数。
* 静态数据成员，静态数据成员相比全局变量的一大优点就是限制了访问权限，另外一个特点就是静态数据成员有可能会被重复定义，所以一般采用的是头文件声明，源文件进行定义，**一定要在类外进行一次定义**。最大特点就是无论创建多少个对象，或者派生类产生了多少个对象，所有对象都只占有一个静态数据成员。**与之类似，函数中声明的静态变量，在函数结束时并不释放，而是等到整个程序结束时才进行释放。**
* 静态成员函数，静态成员之所以只能操作静态数据成员，是因为静态成员函数不属于任何一个对象，所以函数参数中也没有this指针，也就没办法访问非静态数据成员。
* 对象所占用空间，这个主要主义的就是两点，一个是内存对齐，另外一个就是虚指针所占空间，指针在64机器所占大小为8个字节。静态成员和成员函数不占用空间。其中空类大小为1的原因是为了避免两个类对象具有相同地址。
* 关于this指针，这个其实在深入探索对象模型里面又说到过，就是在调用成员函数的时候会隐式传入this指针，通过指针去访问每个对象的成员。
* 类模板，多个类的功能类似，仅仅是数据类型不一样的时候，就可以用到模板。有一点需要注意的是类外进行模板类的成员函数定义，还要再次添加模板声明。
* 构造函数和析构函数的调用时机。如果内存位置在栈中，想像一下栈的空间结构，先进后出，所以最晚构造的对象最先调用析构函数，最早构造的对象最晚调用析构函数。全局对象则是等待整个程序快要结束时进行析构函数的调用。

#### 继承与派生
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继承的方式有public,private以及protected。**派生类有一个缺点就是他会全盘继承基类的所有成员，即使有的成员用不到也要全盘复制，这样就容易造成数据的冗余，所以要根据派生类的需要谨慎选择基类。**
> * 关于基类访问权限，不仅和原本的权限修饰符有关，而且还和继承方式有关。
> * 主要记住一点就好，就是基类的私有成员派生类都不可以访问，然后public继承原有public和protected成员的权限都不会改变，protected继承之后原有public和protected成员都变成protected,private继承原有public和protected成员都会变成private权限，当然基类的私有成员还是不可以访问。
> * 派生类构造函数需要注意的一些点，成员对象以及基类的构造函数参数的初始化必须在初始化列表中进行。
> * 派生类是无法继承基类的析构函数的，所以在派生类中如果有必要需要需要重新定义析构函数来对派生类新增的数据成员进行清理，当调用子类的析构函数时，编译器会自动调用成员对象和基类的析构函数。
> * 关于派生之中各种构造函数调用的顺序，先是最上层的基类调用构造函数，然后是对象成员调用，最后才是派生类调用自己的构造函数。

#### 类的多态
虚函数是C++实现多台的一个非常重要的特性。